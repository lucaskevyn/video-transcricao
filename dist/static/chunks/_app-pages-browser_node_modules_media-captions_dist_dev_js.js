"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_media-captions_dist_dev_js"],{

/***/ "(app-pages-browser)/./node_modules/media-captions/dist/dev.js":
/*!*************************************************!*\
  !*** ./node_modules/media-captions/dist/dev.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CaptionsRenderer: function() { return /* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.C; },\n/* harmony export */   ParseError: function() { return /* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.P; },\n/* harmony export */   ParseErrorCode: function() { return /* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.c; },\n/* harmony export */   TextCue: function() { return /* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.T; },\n/* harmony export */   VTTCue: function() { return /* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.b; },\n/* harmony export */   VTTRegion: function() { return /* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.h; },\n/* harmony export */   createVTTCueTemplate: function() { return /* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.i; },\n/* harmony export */   parseByteStream: function() { return /* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.e; },\n/* harmony export */   parseResponse: function() { return /* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.d; },\n/* harmony export */   parseText: function() { return /* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.f; },\n/* harmony export */   parseTextStream: function() { return /* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.g; },\n/* harmony export */   parseVTTTimestamp: function() { return /* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.p; },\n/* harmony export */   renderVTTCueString: function() { return /* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.r; },\n/* harmony export */   renderVTTTokensString: function() { return /* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.j; },\n/* harmony export */   tokenizeVTTCue: function() { return /* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.t; },\n/* harmony export */   updateTimedVTTCueNodes: function() { return /* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.u; }\n/* harmony export */ });\n/* harmony import */ var _dev_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dev/index.js */ \"(app-pages-browser)/./node_modules/media-captions/dist/dev/index.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jYXB0aW9ucy9kaXN0L2Rldi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVkaWEtY2FwdGlvbnMvZGlzdC9kZXYuanM/YWYxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBDIGFzIENhcHRpb25zUmVuZGVyZXIsIFAgYXMgUGFyc2VFcnJvciwgYyBhcyBQYXJzZUVycm9yQ29kZSwgVCBhcyBUZXh0Q3VlLCBiIGFzIFZUVEN1ZSwgaCBhcyBWVFRSZWdpb24sIGkgYXMgY3JlYXRlVlRUQ3VlVGVtcGxhdGUsIGUgYXMgcGFyc2VCeXRlU3RyZWFtLCBkIGFzIHBhcnNlUmVzcG9uc2UsIGYgYXMgcGFyc2VUZXh0LCBnIGFzIHBhcnNlVGV4dFN0cmVhbSwgcCBhcyBwYXJzZVZUVFRpbWVzdGFtcCwgciBhcyByZW5kZXJWVFRDdWVTdHJpbmcsIGogYXMgcmVuZGVyVlRUVG9rZW5zU3RyaW5nLCB0IGFzIHRva2VuaXplVlRUQ3VlLCB1IGFzIHVwZGF0ZVRpbWVkVlRUQ3VlTm9kZXMgfSBmcm9tICcuL2Rldi9pbmRleC5qcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-captions/dist/dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/media-captions/dist/dev/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/media-captions/dist/dev/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: function() { return /* binding */ CaptionsRenderer; },\n/* harmony export */   P: function() { return /* binding */ ParseError; },\n/* harmony export */   T: function() { return /* binding */ TextCue; },\n/* harmony export */   V: function() { return /* binding */ VTTParser; },\n/* harmony export */   a: function() { return /* binding */ VTTBlock; },\n/* harmony export */   b: function() { return /* binding */ VTTCue; },\n/* harmony export */   c: function() { return /* binding */ ParseErrorCode; },\n/* harmony export */   d: function() { return /* binding */ parseResponse; },\n/* harmony export */   e: function() { return /* binding */ parseByteStream; },\n/* harmony export */   f: function() { return /* binding */ parseText; },\n/* harmony export */   g: function() { return /* binding */ parseTextStream; },\n/* harmony export */   h: function() { return /* binding */ VTTRegion; },\n/* harmony export */   i: function() { return /* binding */ createVTTCueTemplate; },\n/* harmony export */   j: function() { return /* binding */ renderVTTTokensString; },\n/* harmony export */   p: function() { return /* binding */ parseVTTTimestamp; },\n/* harmony export */   r: function() { return /* binding */ renderVTTCueString; },\n/* harmony export */   t: function() { return /* binding */ tokenizeVTTCue; },\n/* harmony export */   u: function() { return /* binding */ updateTimedVTTCueNodes; }\n/* harmony export */ });\nconst ParseErrorCode = {\n  LoadFail: 0,\n  BadSignature: 1,\n  BadTimestamp: 2,\n  BadSettingValue: 3,\n  BadFormat: 4,\n  UnknownSetting: 5\n};\nclass ParseError extends Error {\n  code;\n  line;\n  constructor(init) {\n    super(init.reason);\n    this.code = init.code;\n    this.line = init.line;\n  }\n}\n\nconst LINE_TERMINATOR_RE = /\\r?\\n|\\r/gm;\nclass TextLineTransformStream {\n  writable;\n  readable;\n  constructor(encoding) {\n    const transformer = new TextStreamLineIterator(encoding);\n    this.writable = new WritableStream({\n      write(chunk) {\n        transformer.transform(chunk);\n      },\n      close() {\n        transformer.close();\n      }\n    });\n    this.readable = new ReadableStream({\n      start(controller) {\n        transformer.onLine = (line) => controller.enqueue(line);\n        transformer.onClose = () => controller.close();\n      }\n    });\n  }\n}\nclass TextStreamLineIterator {\n  _buffer = \"\";\n  _decoder;\n  onLine;\n  onClose;\n  constructor(encoding) {\n    this._decoder = new TextDecoder(encoding);\n  }\n  transform(chunk) {\n    this._buffer += this._decoder.decode(chunk, { stream: true });\n    const lines = this._buffer.split(LINE_TERMINATOR_RE);\n    this._buffer = lines.pop() || \"\";\n    for (let i = 0; i < lines.length; i++)\n      this.onLine(lines[i].trim());\n  }\n  close() {\n    if (this._buffer)\n      this.onLine(this._buffer.trim());\n    this._buffer = \"\";\n    this.onClose();\n  }\n}\n\nasync function parseText(text, options) {\n  const stream = new ReadableStream({\n    start(controller) {\n      const lines = text.split(LINE_TERMINATOR_RE);\n      for (const line of lines)\n        controller.enqueue(line);\n      controller.close();\n    }\n  });\n  return parseTextStream(stream, options);\n}\nasync function parseTextStream(stream, options) {\n  const type = options?.type ?? \"vtt\";\n  let factory;\n  if (typeof type === \"string\") {\n    switch (type) {\n      case \"srt\":\n        factory = (await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_media-captions_dist_dev_srt-parser_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./srt-parser.js */ \"(app-pages-browser)/./node_modules/media-captions/dist/dev/srt-parser.js\"))).default;\n        break;\n      case \"ssa\":\n      case \"ass\":\n        factory = (await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_media-captions_dist_dev_ssa-parser_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./ssa-parser.js */ \"(app-pages-browser)/./node_modules/media-captions/dist/dev/ssa-parser.js\"))).default;\n        break;\n      default:\n        factory = (await Promise.resolve().then(function () { return vttParser; })).default;\n    }\n  } else {\n    factory = type;\n  }\n  let result;\n  const reader = stream.getReader(), parser = factory(), errors = options?.errors !== false || !!options?.strict || !!options?.errors;\n  await parser.init({\n    strict: false,\n    ...options,\n    errors,\n    type,\n    cancel() {\n      reader.cancel();\n      result = parser.done(true);\n    }\n  });\n  let i = 1;\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) {\n      parser.parse(\"\", i);\n      result = parser.done(false);\n      break;\n    }\n    parser.parse(value, i);\n    i++;\n  }\n  return result;\n}\n\nasync function parseResponse(response, options) {\n  const res = await response;\n  if (!res.ok || !res.body) {\n    let error;\n    {\n      error = new ParseError({\n        code: ParseErrorCode.LoadFail,\n        reason: !res.ok ? `response is not ok (status: ${res.status})` : `response body is missing (status: ${res.status})`,\n        line: -1\n      });\n      options?.onError?.(error);\n    }\n    return {\n      metadata: {},\n      cues: [],\n      regions: [],\n      errors: [error]\n    };\n  }\n  const contentType = res.headers.get(\"content-type\") || \"\", type = contentType.match(/text\\/(.*?)(?:;|$)/)?.[1], encoding = contentType.match(/charset=(.*?)(?:;|$)/)?.[1];\n  return parseByteStream(res.body, { type, encoding, ...options });\n}\nasync function parseByteStream(stream, { encoding = \"utf-8\", ...options } = {}) {\n  const textStream = stream.pipeThrough(new TextLineTransformStream(encoding));\n  return parseTextStream(textStream, options);\n}\n\nclass TextCue extends EventTarget {\n  /**\n   * A string that identifies the cue.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/id}\n   */\n  id = \"\";\n  /**\n   * A `double` that represents the video time that the cue will start being displayed, in seconds.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/startTime}\n   */\n  startTime;\n  /**\n   * A `double` that represents the video time that the cue will stop being displayed, in seconds.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/endTime}\n   */\n  endTime;\n  /**\n   * Returns a string with the contents of the cue.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/text}\n   */\n  text;\n  /**\n   * A `boolean` for whether the video will pause when this cue stops being displayed.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/pauseOnExit}\n   */\n  pauseOnExit = false;\n  constructor(startTime, endTime, text) {\n    super();\n    this.startTime = startTime;\n    this.endTime = endTime;\n    this.text = text;\n  }\n  addEventListener(type, listener, options) {\n    super.addEventListener(type, listener, options);\n  }\n  removeEventListener(type, listener, options) {\n    super.removeEventListener(type, listener, options);\n  }\n}\n\nconst IS_SERVER = typeof document === \"undefined\";\n\nconst CueBase = IS_SERVER ? TextCue : window.VTTCue;\nclass VTTCue extends CueBase {\n  /**\n   * A `VTTRegion` object describing the video's sub-region that the cue will be drawn onto,\n   * or `null` if none is assigned.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/region}\n   */\n  region = null;\n  /**\n   * The cue writing direction.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/vertical}\n   */\n  vertical = \"\";\n  /**\n   * Returns `true` if the `VTTCue.line` attribute is an integer number of lines or a percentage\n   * of the video size.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/snapToLines}\n   */\n  snapToLines = true;\n  /**\n   * Returns the line positioning of the cue. This can be the string `'auto'` or a number whose\n   * interpretation depends on the value of `VTTCue.snapToLines`.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/line}\n   */\n  line = \"auto\";\n  /**\n   * Returns an enum representing the alignment of the `VTTCue.line`.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/lineAlign}\n   */\n  lineAlign = \"start\";\n  /**\n   * Returns the indentation of the cue within the line. This can be the string `'auto'` or a\n   * number representing the percentage of the `VTTCue.region`, or the video size if `VTTCue`.region`\n   * is `null`.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/position}\n   */\n  position = \"auto\";\n  /**\n   * Returns an enum representing the alignment of the cue. This is used to determine what\n   * the `VTTCue.position` is anchored to. The default is `'auto'`.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/positionAlign}\n   */\n  positionAlign = \"auto\";\n  /**\n   * Returns a double representing the size of the cue, as a percentage of the video size.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/size}\n   */\n  size = 100;\n  /**\n   * Returns an enum representing the alignment of all the lines of text within the cue box.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/align}\n   */\n  align = \"center\";\n  /**\n   * Additional styles associated with the cue.\n   */\n  style;\n}\n\nclass VTTRegion {\n  /**\n   * A string that identifies the region.\n   */\n  id = \"\";\n  /**\n   * A `double` representing the width of the region, as a percentage of the video.\n   */\n  width = 100;\n  /**\n   * A `double` representing the height of the region, in number of lines.\n   */\n  lines = 3;\n  /**\n   * A `double` representing the region anchor X offset, as a percentage of the region.\n   */\n  regionAnchorX = 0;\n  /**\n   * A `double` representing the region anchor Y offset, as a percentage of the region.\n   */\n  regionAnchorY = 100;\n  /**\n   * A `double` representing the viewport anchor X offset, as a percentage of the video.\n   */\n  viewportAnchorX = 0;\n  /**\n   * A `double` representing the viewport anchor Y offset, as a percentage of the video.\n   */\n  viewportAnchorY = 100;\n  /**\n   * An enum representing how adding new cues will move existing cues.\n   */\n  scroll = \"\";\n}\n\nconst COMMA$1 = \",\", PERCENT_SIGN$1 = \"%\";\nfunction toNumber(text) {\n  const num = parseInt(text, 10);\n  return !Number.isNaN(num) ? num : null;\n}\nfunction toPercentage(text) {\n  const num = parseInt(text.replace(PERCENT_SIGN$1, \"\"), 10);\n  return !Number.isNaN(num) && num >= 0 && num <= 100 ? num : null;\n}\nfunction toCoords(text) {\n  if (!text.includes(COMMA$1))\n    return null;\n  const [x, y] = text.split(COMMA$1).map(toPercentage);\n  return x !== null && y !== null ? [x, y] : null;\n}\nfunction toFloat(text) {\n  const num = parseFloat(text);\n  return !Number.isNaN(num) ? num : null;\n}\n\nconst HEADER_MAGIC = \"WEBVTT\", COMMA = \",\", PERCENT_SIGN = \"%\", SETTING_SEP_RE = /[:=]/, SETTING_LINE_RE = /^[\\s\\t]*(region|vertical|line|position|size|align)[:=]/, NOTE_BLOCK_START = \"NOTE\", REGION_BLOCK_START = \"REGION\", REGION_BLOCK_START_RE = /^REGION:?[\\s\\t]+/, SPACE_RE = /[\\s\\t]+/, TIMESTAMP_SEP = \"-->\", TIMESTAMP_SEP_RE = /[\\s\\t]*-->[\\s\\t]+/, ALIGN_RE = /start|center|end|left|right/, LINE_ALIGN_RE = /start|center|end/, POS_ALIGN_RE = /line-(?:left|right)|center|auto/, TIMESTAMP_RE = /^(?:(\\d{1,2}):)?(\\d{2}):(\\d{2})(?:\\.(\\d{1,3}))?$/;\nvar VTTBlock = /* @__PURE__ */ ((VTTBlock2) => {\n  VTTBlock2[VTTBlock2[\"None\"] = 0] = \"None\";\n  VTTBlock2[VTTBlock2[\"Header\"] = 1] = \"Header\";\n  VTTBlock2[VTTBlock2[\"Cue\"] = 2] = \"Cue\";\n  VTTBlock2[VTTBlock2[\"Region\"] = 3] = \"Region\";\n  VTTBlock2[VTTBlock2[\"Note\"] = 4] = \"Note\";\n  return VTTBlock2;\n})(VTTBlock || {});\nclass VTTParser {\n  _init;\n  _block = 0 /* None */;\n  _metadata = {};\n  _regions = {};\n  _cues = [];\n  _cue = null;\n  _region = null;\n  _errors = [];\n  _errorBuilder;\n  _prevLine = \"\";\n  async init(init) {\n    this._init = init;\n    if (init.strict)\n      this._block = 1 /* Header */;\n    if (init.errors)\n      this._errorBuilder = (await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_media-captions_dist_dev_errors_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./errors.js */ \"(app-pages-browser)/./node_modules/media-captions/dist/dev/errors.js\"))).ParseErrorBuilder;\n  }\n  parse(line, lineCount) {\n    if (line === \"\") {\n      if (this._cue) {\n        this._cues.push(this._cue);\n        this._init.onCue?.(this._cue);\n        this._cue = null;\n      } else if (this._region) {\n        this._regions[this._region.id] = this._region;\n        this._init.onRegion?.(this._region);\n        this._region = null;\n      } else if (this._block === 1 /* Header */) {\n        this._parseHeader(line, lineCount);\n        this._init.onHeaderMetadata?.(this._metadata);\n      }\n      this._block = 0 /* None */;\n    } else if (this._block) {\n      switch (this._block) {\n        case 1 /* Header */:\n          this._parseHeader(line, lineCount);\n          break;\n        case 2 /* Cue */:\n          if (this._cue) {\n            const hasText = this._cue.text.length > 0;\n            if (!hasText && SETTING_LINE_RE.test(line)) {\n              this._parseCueSettings(line.split(SPACE_RE), lineCount);\n            } else {\n              this._cue.text += (hasText ? \"\\n\" : \"\") + line;\n            }\n          }\n          break;\n        case 3 /* Region */:\n          this._parseRegionSettings(line.split(SPACE_RE), lineCount);\n          break;\n      }\n    } else if (line.startsWith(NOTE_BLOCK_START)) {\n      this._block = 4 /* Note */;\n    } else if (line.startsWith(REGION_BLOCK_START)) {\n      this._block = 3 /* Region */;\n      this._region = new VTTRegion();\n      this._parseRegionSettings(line.replace(REGION_BLOCK_START_RE, \"\").split(SPACE_RE), lineCount);\n    } else if (line.includes(TIMESTAMP_SEP)) {\n      const result = this._parseTimestamp(line, lineCount);\n      if (result) {\n        this._cue = new VTTCue(result[0], result[1], \"\");\n        this._cue.id = this._prevLine;\n        this._parseCueSettings(result[2], lineCount);\n      }\n      this._block = 2 /* Cue */;\n    } else if (lineCount === 1) {\n      this._parseHeader(line, lineCount);\n    }\n    this._prevLine = line;\n  }\n  done() {\n    return {\n      metadata: this._metadata,\n      cues: this._cues,\n      regions: Object.values(this._regions),\n      errors: this._errors\n    };\n  }\n  _parseHeader(line, lineCount) {\n    if (lineCount > 1) {\n      if (SETTING_SEP_RE.test(line)) {\n        const [key, value] = line.split(SETTING_SEP_RE);\n        if (key)\n          this._metadata[key] = (value || \"\").replace(SPACE_RE, \"\");\n      }\n    } else if (line.startsWith(HEADER_MAGIC)) {\n      this._block = 1 /* Header */;\n    } else {\n      this._handleError(this._errorBuilder?._badVTTHeader());\n    }\n  }\n  _parseTimestamp(line, lineCount) {\n    const [startTimeText, trailingText = \"\"] = line.split(TIMESTAMP_SEP_RE), [endTimeText, ...settingsText] = trailingText.split(SPACE_RE), startTime = parseVTTTimestamp(startTimeText), endTime = parseVTTTimestamp(endTimeText);\n    if (startTime !== null && endTime !== null && endTime > startTime) {\n      return [startTime, endTime, settingsText];\n    } else {\n      if (startTime === null) {\n        this._handleError(this._errorBuilder?._badStartTimestamp(startTimeText, lineCount));\n      }\n      if (endTime === null) {\n        this._handleError(this._errorBuilder?._badEndTimestamp(endTimeText, lineCount));\n      }\n      if (startTime != null && endTime !== null && endTime > startTime) {\n        this._handleError(this._errorBuilder?._badRangeTimestamp(startTime, endTime, lineCount));\n      }\n    }\n  }\n  /**\n   * @see {@link https://www.w3.org/TR/webvtt1/#region-settings-parsing}\n   */\n  _parseRegionSettings(settings, line) {\n    let badValue;\n    for (let i = 0; i < settings.length; i++) {\n      if (SETTING_SEP_RE.test(settings[i])) {\n        badValue = false;\n        const [name, value] = settings[i].split(SETTING_SEP_RE);\n        switch (name) {\n          case \"id\":\n            this._region.id = value;\n            break;\n          case \"width\":\n            const width = toPercentage(value);\n            if (width !== null)\n              this._region.width = width;\n            else\n              badValue = true;\n            break;\n          case \"lines\":\n            const lines = toNumber(value);\n            if (lines !== null)\n              this._region.lines = lines;\n            else\n              badValue = true;\n            break;\n          case \"regionanchor\":\n            const region = toCoords(value);\n            if (region !== null) {\n              this._region.regionAnchorX = region[0];\n              this._region.regionAnchorY = region[1];\n            } else\n              badValue = true;\n            break;\n          case \"viewportanchor\":\n            const viewport = toCoords(value);\n            if (viewport !== null) {\n              this._region.viewportAnchorX = viewport[0];\n              this._region.viewportAnchorY = viewport[1];\n            } else\n              badValue = true;\n            break;\n          case \"scroll\":\n            if (value === \"up\")\n              this._region.scroll = \"up\";\n            else\n              badValue = true;\n            break;\n          default:\n            this._handleError(this._errorBuilder?._unknownRegionSetting(name, value, line));\n        }\n        if (badValue) {\n          this._handleError(this._errorBuilder?._badRegionSetting(name, value, line));\n        }\n      }\n    }\n  }\n  /**\n   * @see {@link https://www.w3.org/TR/webvtt1/#cue-timings-and-settings-parsing}\n   */\n  _parseCueSettings(settings, line) {\n    let badValue;\n    for (let i = 0; i < settings.length; i++) {\n      badValue = false;\n      if (SETTING_SEP_RE.test(settings[i])) {\n        const [name, value] = settings[i].split(SETTING_SEP_RE);\n        switch (name) {\n          case \"region\":\n            const region = this._regions[value];\n            if (region)\n              this._cue.region = region;\n            break;\n          case \"vertical\":\n            if (value === \"lr\" || value === \"rl\") {\n              this._cue.vertical = value;\n              this._cue.region = null;\n            } else\n              badValue = true;\n            break;\n          case \"line\":\n            const [linePos, lineAlign] = value.split(COMMA);\n            if (linePos.includes(PERCENT_SIGN)) {\n              const percentage = toPercentage(linePos);\n              if (percentage !== null) {\n                this._cue.line = percentage;\n                this._cue.snapToLines = false;\n              } else\n                badValue = true;\n            } else {\n              const number = toFloat(linePos);\n              if (number !== null)\n                this._cue.line = number;\n              else\n                badValue = true;\n            }\n            if (LINE_ALIGN_RE.test(lineAlign)) {\n              this._cue.lineAlign = lineAlign;\n            } else if (lineAlign) {\n              badValue = true;\n            }\n            if (this._cue.line !== \"auto\")\n              this._cue.region = null;\n            break;\n          case \"position\":\n            const [colPos, colAlign] = value.split(COMMA), position = toPercentage(colPos);\n            if (position !== null)\n              this._cue.position = position;\n            else\n              badValue = true;\n            if (colAlign && POS_ALIGN_RE.test(colAlign)) {\n              this._cue.positionAlign = colAlign;\n            } else if (colAlign) {\n              badValue = true;\n            }\n            break;\n          case \"size\":\n            const size = toPercentage(value);\n            if (size !== null) {\n              this._cue.size = size;\n              if (size < 100)\n                this._cue.region = null;\n            } else {\n              badValue = true;\n            }\n            break;\n          case \"align\":\n            if (ALIGN_RE.test(value)) {\n              this._cue.align = value;\n            } else {\n              badValue = true;\n            }\n            break;\n          default:\n            this._handleError(this._errorBuilder?._unknownCueSetting(name, value, line));\n        }\n        if (badValue) {\n          this._handleError(this._errorBuilder?._badCueSetting(name, value, line));\n        }\n      }\n    }\n  }\n  _handleError(error) {\n    if (!error)\n      return;\n    this._errors.push(error);\n    if (this._init.strict) {\n      this._init.cancel();\n      throw error;\n    } else {\n      this._init.onError?.(error);\n    }\n  }\n}\nfunction parseVTTTimestamp(timestamp) {\n  const match = timestamp.match(TIMESTAMP_RE);\n  if (!match)\n    return null;\n  const hours = match[1] ? parseInt(match[1], 10) : 0, minutes = parseInt(match[2], 10), seconds = parseInt(match[3], 10), milliseconds = match[4] ? parseInt(match[4].padEnd(3, \"0\"), 10) : 0, total = hours * 3600 + minutes * 60 + seconds + milliseconds / 1e3;\n  if (hours < 0 || minutes < 0 || seconds < 0 || milliseconds < 0 || minutes > 59 || seconds > 59) {\n    return null;\n  }\n  return total;\n}\nfunction createVTTParser() {\n  return new VTTParser();\n}\n\nvar vttParser = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  VTTBlock: VTTBlock,\n  VTTParser: VTTParser,\n  default: createVTTParser,\n  parseVTTTimestamp: parseVTTTimestamp\n});\n\nconst DIGIT_RE = /[0-9]/, MULTI_SPACE_RE = /[\\s\\t]+/, TAG_NAME = {\n  c: \"span\",\n  i: \"i\",\n  b: \"b\",\n  u: \"u\",\n  ruby: \"ruby\",\n  rt: \"rt\",\n  v: \"span\",\n  lang: \"span\",\n  timestamp: \"span\"\n}, HTML_ENTITIES = {\n  \"&amp;\": \"&\",\n  \"&lt;\": \"<\",\n  \"&gt;\": \">\",\n  \"&quot;\": '\"',\n  \"&#39;\": \"'\",\n  \"&nbsp;\": \"\\xA0\",\n  \"&lrm;\": \"\\u200E\",\n  \"&rlm;\": \"\\u200F\"\n}, HTML_ENTITY_RE = /&(?:amp|lt|gt|quot|#(0+)?39|nbsp|lrm|rlm);/g, COLORS = /* @__PURE__ */ new Set([\n  \"white\",\n  \"lime\",\n  \"cyan\",\n  \"red\",\n  \"yellow\",\n  \"magenta\",\n  \"blue\",\n  \"black\"\n]), BLOCK_TYPES = /* @__PURE__ */ new Set(Object.keys(TAG_NAME));\nfunction tokenizeVTTCue(cue) {\n  let buffer = \"\", mode = 1 /* Data */, result = [], stack = [], node;\n  for (let i = 0; i < cue.text.length; i++) {\n    const char = cue.text[i];\n    switch (mode) {\n      case 1 /* Data */:\n        if (char === \"<\") {\n          addText();\n          mode = 2 /* Tag */;\n        } else {\n          buffer += char;\n        }\n        break;\n      case 2 /* Tag */:\n        switch (char) {\n          case \"\\n\":\n          case \"\t\":\n          case \" \":\n            addNode();\n            mode = 4 /* Annotation */;\n            break;\n          case \".\":\n            addNode();\n            mode = 3 /* Class */;\n            break;\n          case \"/\":\n            mode = 5 /* EndTag */;\n            break;\n          case \">\":\n            addNode();\n            mode = 1 /* Data */;\n            break;\n          default:\n            if (!buffer && DIGIT_RE.test(char))\n              mode = 6 /* Timestamp */;\n            buffer += char;\n            break;\n        }\n        break;\n      case 3 /* Class */:\n        switch (char) {\n          case \"\t\":\n          case \" \":\n          case \"\\n\":\n            addClass();\n            if (node)\n              node.class?.trim();\n            mode = 4 /* Annotation */;\n            break;\n          case \".\":\n            addClass();\n            break;\n          case \">\":\n            addClass();\n            if (node)\n              node.class?.trim();\n            mode = 1 /* Data */;\n            break;\n          default:\n            buffer += char;\n        }\n        break;\n      case 4 /* Annotation */:\n        if (char === \">\") {\n          buffer = buffer.replace(MULTI_SPACE_RE, \" \");\n          if (node?.type === \"v\")\n            node.voice = replaceHTMLEntities(buffer);\n          else if (node?.type === \"lang\")\n            node.lang = replaceHTMLEntities(buffer);\n          buffer = \"\";\n          mode = 1 /* Data */;\n        } else {\n          buffer += char;\n        }\n        break;\n      case 5 /* EndTag */:\n        if (char === \">\") {\n          buffer = \"\";\n          node = stack.pop();\n          mode = 1 /* Data */;\n        }\n        break;\n      case 6 /* Timestamp */:\n        if (char === \">\") {\n          const time = parseVTTTimestamp(buffer);\n          if (time !== null && time >= cue.startTime && time <= cue.endTime) {\n            buffer = \"timestamp\";\n            addNode();\n            node.time = time;\n          }\n          buffer = \"\";\n          mode = 1 /* Data */;\n        } else {\n          buffer += char;\n        }\n        break;\n    }\n  }\n  function addNode() {\n    if (BLOCK_TYPES.has(buffer)) {\n      const parent = node;\n      node = createBlockNode(buffer);\n      if (parent) {\n        if (stack[stack.length - 1] !== parent)\n          stack.push(parent);\n        parent.children.push(node);\n      } else\n        result.push(node);\n    }\n    buffer = \"\";\n    mode = 1 /* Data */;\n  }\n  function addClass() {\n    if (node && buffer) {\n      const color = buffer.replace(\"bg_\", \"\");\n      if (COLORS.has(color)) {\n        node[buffer.startsWith(\"bg_\") ? \"bgColor\" : \"color\"] = color;\n      } else {\n        node.class = !node.class ? buffer : node.class + \" \" + buffer;\n      }\n    }\n    buffer = \"\";\n  }\n  function addText() {\n    if (!buffer)\n      return;\n    const text = { type: \"text\", data: replaceHTMLEntities(buffer) };\n    node ? node.children.push(text) : result.push(text);\n    buffer = \"\";\n  }\n  if (mode === 1 /* Data */)\n    addText();\n  return result;\n}\nfunction createBlockNode(type) {\n  return {\n    tagName: TAG_NAME[type],\n    type,\n    children: []\n  };\n}\nfunction replaceHTMLEntities(text) {\n  return text.replace(HTML_ENTITY_RE, (entity) => HTML_ENTITIES[entity] || \"'\");\n}\n\nfunction setCSSVar(el, name, value) {\n  el.style.setProperty(`--${name}`, value + \"\");\n}\nfunction setDataAttr(el, name, value = true) {\n  el.setAttribute(`data-${name}`, value === true ? \"\" : value + \"\");\n}\nfunction setPartAttr(el, name) {\n  el.setAttribute(\"data-part\", name);\n}\nfunction getLineHeight(el) {\n  return parseFloat(getComputedStyle(el).lineHeight) || 0;\n}\n\nfunction createVTTCueTemplate(cue) {\n  if (IS_SERVER) {\n    throw Error(\n      \"[media-captions] called `createVTTCueTemplate` on the server - use `renderVTTCueString`\"\n    );\n  }\n  const template = document.createElement(\"template\");\n  template.innerHTML = renderVTTCueString(cue);\n  return { cue, content: template.content };\n}\nfunction renderVTTCueString(cue, currentTime = 0) {\n  return renderVTTTokensString(tokenizeVTTCue(cue), currentTime);\n}\nfunction renderVTTTokensString(tokens, currentTime = 0) {\n  let attrs, result = \"\";\n  for (const token of tokens) {\n    if (token.type === \"text\") {\n      result += token.data;\n    } else {\n      const isTimestamp = token.type === \"timestamp\";\n      attrs = {};\n      attrs.class = token.class;\n      attrs.title = token.type === \"v\" && token.voice;\n      attrs.lang = token.type === \"lang\" && token.lang;\n      attrs[\"data-part\"] = token.type === \"v\" && \"voice\";\n      if (isTimestamp) {\n        attrs[\"data-part\"] = \"timed\";\n        attrs[\"data-time\"] = token.time;\n        attrs[\"data-future\"] = token.time > currentTime;\n        attrs[\"data-past\"] = token.time < currentTime;\n      }\n      attrs.style = `${token.color ? `color: ${token.color};` : \"\"}${token.bgColor ? `background-color: ${token.bgColor};` : \"\"}`;\n      const attributes = Object.entries(attrs).filter((v) => v[1]).map((v) => `${v[0]}=\"${v[1] === true ? \"\" : v[1]}\"`).join(\" \");\n      result += `<${token.tagName}${attributes ? \" \" + attributes : \"\"}>${renderVTTTokensString(\n        token.children\n      )}</${token.tagName}>`;\n    }\n  }\n  return result;\n}\nfunction updateTimedVTTCueNodes(root, currentTime) {\n  if (IS_SERVER)\n    return;\n  for (const el of root.querySelectorAll('[data-part=\"timed\"]')) {\n    const time = Number(el.getAttribute(\"data-time\"));\n    if (Number.isNaN(time))\n      continue;\n    if (time > currentTime)\n      setDataAttr(el, \"future\");\n    else\n      el.removeAttribute(\"data-future\");\n    if (time < currentTime)\n      setDataAttr(el, \"past\");\n    else\n      el.removeAttribute(\"data-past\");\n  }\n}\n\nfunction debounce(fn, delay) {\n  let timeout = null, args;\n  function run() {\n    clear();\n    fn(...args);\n    args = void 0;\n  }\n  function clear() {\n    clearTimeout(timeout);\n    timeout = null;\n  }\n  function debounce2() {\n    args = [].slice.call(arguments);\n    clear();\n    timeout = setTimeout(run, delay);\n  }\n  return debounce2;\n}\n\nconst STARTING_BOX = Symbol(\"STARTING_BOX\" );\nfunction createBox(box) {\n  if (box instanceof HTMLElement) {\n    return {\n      top: box.offsetTop,\n      width: box.clientWidth,\n      height: box.clientHeight,\n      left: box.offsetLeft,\n      right: box.offsetLeft + box.clientWidth,\n      bottom: box.offsetTop + box.clientHeight\n    };\n  }\n  return { ...box };\n}\nfunction moveBox(box, axis, delta) {\n  switch (axis) {\n    case \"+x\":\n      box.left += delta;\n      box.right += delta;\n      break;\n    case \"-x\":\n      box.left -= delta;\n      box.right -= delta;\n      break;\n    case \"+y\":\n      box.top += delta;\n      box.bottom += delta;\n      break;\n    case \"-y\":\n      box.top -= delta;\n      box.bottom -= delta;\n      break;\n  }\n}\nfunction isBoxCollision(a, b) {\n  return a.left <= b.right && a.right >= b.left && a.top <= b.bottom && a.bottom >= b.top;\n}\nfunction isAnyBoxCollision(box, boxes) {\n  for (let i = 0; i < boxes.length; i++)\n    if (isBoxCollision(box, boxes[i]))\n      return boxes[i];\n  return null;\n}\nfunction isWithinBox(container, box) {\n  return box.top >= 0 && box.bottom <= container.height && box.left >= 0 && box.right <= container.width;\n}\nfunction isBoxOutOfBounds(container, box, axis) {\n  switch (axis) {\n    case \"+x\":\n      return box.left < 0;\n    case \"-x\":\n      return box.right > container.width;\n    case \"+y\":\n      return box.top < 0;\n    case \"-y\":\n      return box.bottom > container.height;\n  }\n}\nfunction calcBoxIntersectPercentage(container, box) {\n  const x = Math.max(0, Math.min(container.width, box.right) - Math.max(0, box.left)), y = Math.max(0, Math.min(container.height, box.bottom) - Math.max(0, box.top)), intersectArea = x * y;\n  return intersectArea / (container.height * container.width);\n}\nfunction createCSSBox(container, box) {\n  return {\n    top: box.top / container.height,\n    left: box.left / container.width,\n    right: (container.width - box.right) / container.width,\n    bottom: (container.height - box.bottom) / container.height\n  };\n}\nfunction resolveRelativeBox(container, box) {\n  box.top = box.top * container.height;\n  box.left = box.left * container.width;\n  box.right = container.width - box.right * container.width;\n  box.bottom = container.height - box.bottom * container.height;\n  return box;\n}\nconst BOX_SIDES = [\"top\", \"left\", \"right\", \"bottom\"];\nfunction setBoxCSSVars(el, container, box, prefix) {\n  const cssBox = createCSSBox(container, box);\n  for (const side of BOX_SIDES) {\n    setCSSVar(el, `${prefix}-${side}`, cssBox[side] * 100 + \"%\");\n  }\n}\nfunction avoidBoxCollisions(container, box, boxes, axis) {\n  let percentage = 1, positionedBox, startBox = { ...box };\n  for (let i = 0; i < axis.length; i++) {\n    while (isBoxOutOfBounds(container, box, axis[i]) || isWithinBox(container, box) && isAnyBoxCollision(box, boxes)) {\n      moveBox(box, axis[i], 1);\n    }\n    if (isWithinBox(container, box))\n      return box;\n    const intersection = calcBoxIntersectPercentage(container, box);\n    if (percentage > intersection) {\n      positionedBox = { ...box };\n      percentage = intersection;\n    }\n    box = { ...startBox };\n  }\n  return positionedBox || startBox;\n}\n\nconst POSITION_OVERRIDE = Symbol(\"POSITION_OVERRIDE\" );\nfunction positionCue(container, cue, displayEl, boxes) {\n  let cueEl = displayEl.firstElementChild, line = computeCueLine(cue), displayBox, axis = [];\n  if (!displayEl[STARTING_BOX]) {\n    displayEl[STARTING_BOX] = createStartingBox(container, displayEl);\n  }\n  displayBox = resolveRelativeBox(container, { ...displayEl[STARTING_BOX] });\n  if (displayEl[POSITION_OVERRIDE]) {\n    axis = [displayEl[POSITION_OVERRIDE] === \"top\" ? \"+y\" : \"-y\", \"+x\", \"-x\"];\n  } else if (cue.snapToLines) {\n    let size;\n    switch (cue.vertical) {\n      case \"\":\n        axis = [\"+y\", \"-y\"];\n        size = \"height\";\n        break;\n      case \"rl\":\n        axis = [\"+x\", \"-x\"];\n        size = \"width\";\n        break;\n      case \"lr\":\n        axis = [\"-x\", \"+x\"];\n        size = \"width\";\n        break;\n    }\n    let step = getLineHeight(cueEl), position = step * Math.round(line), maxPosition = container[size] + step, initialAxis = axis[0];\n    if (Math.abs(position) > maxPosition) {\n      position = position < 0 ? -1 : 1;\n      position *= Math.ceil(maxPosition / step) * step;\n    }\n    if (line < 0) {\n      position += cue.vertical === \"\" ? container.height : container.width;\n      axis = axis.reverse();\n    }\n    moveBox(displayBox, initialAxis, position);\n  } else {\n    const isHorizontal = cue.vertical === \"\", posAxis = isHorizontal ? \"+y\" : \"+x\", size = isHorizontal ? displayBox.height : displayBox.width;\n    moveBox(\n      displayBox,\n      posAxis,\n      (isHorizontal ? container.height : container.width) * line / 100\n    );\n    moveBox(\n      displayBox,\n      posAxis,\n      cue.lineAlign === \"center\" ? size / 2 : cue.lineAlign === \"end\" ? size : 0\n    );\n    axis = isHorizontal ? [\"-y\", \"+y\", \"-x\", \"+x\"] : [\"-x\", \"+x\", \"-y\", \"+y\"];\n  }\n  displayBox = avoidBoxCollisions(container, displayBox, boxes, axis);\n  setBoxCSSVars(displayEl, container, displayBox, \"cue\");\n  return displayBox;\n}\nfunction createStartingBox(container, cueEl) {\n  const box = createBox(cueEl), pos = getStyledPositions(cueEl);\n  cueEl[POSITION_OVERRIDE] = false;\n  if (pos.top) {\n    box.top = pos.top;\n    box.bottom = pos.top + box.height;\n    cueEl[POSITION_OVERRIDE] = \"top\";\n  }\n  if (pos.bottom) {\n    const bottom = container.height - pos.bottom;\n    box.top = bottom - box.height;\n    box.bottom = bottom;\n    cueEl[POSITION_OVERRIDE] = \"bottom\";\n  }\n  if (pos.left)\n    box.left = pos.left;\n  if (pos.right)\n    box.right = container.width - pos.right;\n  return createCSSBox(container, box);\n}\nfunction getStyledPositions(el) {\n  const positions = {};\n  for (const side of BOX_SIDES) {\n    positions[side] = parseFloat(el.style.getPropertyValue(`--cue-${side}`));\n  }\n  return positions;\n}\nfunction computeCueLine(cue) {\n  if (cue.line === \"auto\") {\n    if (!cue.snapToLines) {\n      return 100;\n    } else {\n      return -1;\n    }\n  }\n  return cue.line;\n}\nfunction computeCuePosition(cue) {\n  if (cue.position === \"auto\") {\n    switch (cue.align) {\n      case \"start\":\n      case \"left\":\n        return 0;\n      case \"right\":\n      case \"end\":\n        return 100;\n      default:\n        return 50;\n    }\n  }\n  return cue.position;\n}\nfunction computeCuePositionAlignment(cue, dir) {\n  if (cue.positionAlign === \"auto\") {\n    switch (cue.align) {\n      case \"start\":\n        return dir === \"ltr\" ? \"line-left\" : \"line-right\";\n      case \"end\":\n        return dir === \"ltr\" ? \"line-right\" : \"line-left\";\n      case \"center\":\n        return \"center\";\n      default:\n        return `line-${cue.align}`;\n    }\n  }\n  return cue.positionAlign;\n}\n\nconst REGION_AXIS = [\"-y\", \"+y\", \"-x\", \"+x\"];\nfunction positionRegion(container, region, regionEl, boxes) {\n  let cues = Array.from(regionEl.querySelectorAll('[data-part=\"cue-display\"]')), height = 0, limit = Math.max(0, cues.length - region.lines);\n  for (let i = cues.length - 1; i >= limit; i--) {\n    height += cues[i].offsetHeight;\n  }\n  setCSSVar(regionEl, \"region-height\", height + \"px\");\n  if (!regionEl[STARTING_BOX]) {\n    regionEl[STARTING_BOX] = createCSSBox(container, createBox(regionEl));\n  }\n  let box = { ...regionEl[STARTING_BOX] };\n  box = resolveRelativeBox(container, box);\n  box.width = regionEl.clientWidth;\n  box.height = height;\n  box.right = box.left + box.width;\n  box.bottom = box.top + height;\n  box = avoidBoxCollisions(container, box, boxes, REGION_AXIS);\n  setBoxCSSVars(regionEl, container, box, \"region\");\n  return box;\n}\n\nclass CaptionsRenderer {\n  overlay;\n  _overlayBox;\n  _currentTime = 0;\n  _dir = \"ltr\";\n  _activeCues = [];\n  _isResizing = false;\n  _resizeObserver;\n  _regions = /* @__PURE__ */ new Map();\n  _cues = /* @__PURE__ */ new Map();\n  /* Text direction. */\n  get dir() {\n    return this._dir;\n  }\n  set dir(dir) {\n    this._dir = dir;\n    setDataAttr(this.overlay, \"dir\", dir);\n  }\n  get currentTime() {\n    return this._currentTime;\n  }\n  set currentTime(time) {\n    this._currentTime = time;\n    this.update();\n  }\n  constructor(overlay, init) {\n    this.overlay = overlay;\n    this.dir = init?.dir ?? \"ltr\";\n    overlay.setAttribute(\"translate\", \"yes\");\n    overlay.setAttribute(\"aria-live\", \"off\");\n    overlay.setAttribute(\"aria-atomic\", \"true\");\n    setPartAttr(overlay, \"captions\");\n    this._updateOverlay();\n    this._resizeObserver = new ResizeObserver(this._resizing.bind(this));\n    this._resizeObserver.observe(overlay);\n  }\n  changeTrack({ regions, cues }) {\n    this.reset();\n    this._buildRegions(regions);\n    for (const cue of cues)\n      this._cues.set(cue, null);\n    this.update();\n  }\n  addCue(cue) {\n    this._cues.set(cue, null);\n    this.update();\n  }\n  removeCue(cue) {\n    this._cues.delete(cue);\n    this.update();\n  }\n  update(forceUpdate = false) {\n    this._render(forceUpdate);\n  }\n  reset() {\n    this._cues.clear();\n    this._regions.clear();\n    this._activeCues = [];\n    this.overlay.textContent = \"\";\n  }\n  destroy() {\n    this.reset();\n    this._resizeObserver.disconnect();\n  }\n  _resizing() {\n    this._isResizing = true;\n    this._resize();\n  }\n  _resize = debounce(() => {\n    this._isResizing = false;\n    this._updateOverlay();\n    for (const el of this._regions.values()) {\n      el[STARTING_BOX] = null;\n    }\n    for (const el of this._cues.values()) {\n      if (el)\n        el[STARTING_BOX] = null;\n    }\n    this._render(true);\n  }, 50);\n  _updateOverlay() {\n    this._overlayBox = createBox(this.overlay);\n    setCSSVar(this.overlay, \"overlay-width\", this._overlayBox.width + \"px\");\n    setCSSVar(this.overlay, \"overlay-height\", this._overlayBox.height + \"px\");\n  }\n  _render(forceUpdate = false) {\n    if (!this._cues.size || this._isResizing)\n      return;\n    let cue, activeCues = [...this._cues.keys()].filter((cue2) => this._currentTime >= cue2.startTime && this._currentTime <= cue2.endTime).sort(\n      (cueA, cueB) => cueA.startTime !== cueB.startTime ? cueA.startTime - cueB.startTime : cueA.endTime - cueB.endTime\n    ), activeRegions = activeCues.map((cue2) => cue2.region);\n    for (let i = 0; i < this._activeCues.length; i++) {\n      cue = this._activeCues[i];\n      if (activeCues[i] === cue)\n        continue;\n      if (cue.region && !activeRegions.includes(cue.region)) {\n        const regionEl = this._regions.get(cue.region.id);\n        if (regionEl) {\n          regionEl.removeAttribute(\"data-active\");\n          forceUpdate = true;\n        }\n      }\n      const cueEl = this._cues.get(cue);\n      if (cueEl) {\n        cueEl.remove();\n        forceUpdate = true;\n      }\n    }\n    for (let i = 0; i < activeCues.length; i++) {\n      cue = activeCues[i];\n      let cueEl = this._cues.get(cue);\n      if (!cueEl)\n        this._cues.set(cue, cueEl = this._createCueElement(cue));\n      const regionEl = this._hasRegion(cue) && this._regions.get(cue.region.id);\n      if (regionEl && !regionEl.hasAttribute(\"data-active\")) {\n        requestAnimationFrame(() => setDataAttr(regionEl, \"active\"));\n        forceUpdate = true;\n      }\n      if (!cueEl.isConnected) {\n        (regionEl || this.overlay).append(cueEl);\n        forceUpdate = true;\n      }\n    }\n    if (forceUpdate) {\n      const boxes = [], seen = /* @__PURE__ */ new Set();\n      for (let i = activeCues.length - 1; i >= 0; i--) {\n        cue = activeCues[i];\n        if (seen.has(cue.region || cue))\n          continue;\n        const isRegion = this._hasRegion(cue), el = isRegion ? this._regions.get(cue.region.id) : this._cues.get(cue);\n        if (isRegion) {\n          boxes.push(positionRegion(this._overlayBox, cue.region, el, boxes));\n        } else {\n          boxes.push(positionCue(this._overlayBox, cue, el, boxes));\n        }\n        seen.add(isRegion ? cue.region : cue);\n      }\n    }\n    updateTimedVTTCueNodes(this.overlay, this._currentTime);\n    this._activeCues = activeCues;\n  }\n  _buildRegions(regions) {\n    if (!regions)\n      return;\n    for (const region of regions) {\n      const el = this._createRegionElement(region);\n      this._regions.set(region.id, el);\n      this.overlay.append(el);\n    }\n  }\n  _createRegionElement(region) {\n    const el = document.createElement(\"div\");\n    setPartAttr(el, \"region\");\n    setDataAttr(el, \"id\", region.id);\n    setDataAttr(el, \"scroll\", region.scroll);\n    setCSSVar(el, \"region-width\", region.width + \"%\");\n    setCSSVar(el, \"region-anchor-x\", region.regionAnchorX);\n    setCSSVar(el, \"region-anchor-y\", region.regionAnchorY);\n    setCSSVar(el, \"region-viewport-anchor-x\", region.viewportAnchorX);\n    setCSSVar(el, \"region-viewport-anchor-y\", region.viewportAnchorY);\n    setCSSVar(el, \"region-lines\", region.lines);\n    return el;\n  }\n  _createCueElement(cue) {\n    const display = document.createElement(\"div\"), position = computeCuePosition(cue), positionAlignment = computeCuePositionAlignment(cue, this._dir);\n    setPartAttr(display, \"cue-display\");\n    if (cue.vertical !== \"\")\n      setDataAttr(display, \"vertical\");\n    setCSSVar(display, \"cue-text-align\", cue.align);\n    if (cue.style) {\n      for (const prop of Object.keys(cue.style)) {\n        display.style.setProperty(prop, cue.style[prop]);\n      }\n    }\n    if (!this._hasRegion(cue)) {\n      setCSSVar(\n        display,\n        \"cue-writing-mode\",\n        cue.vertical === \"\" ? \"horizontal-tb\" : cue.vertical === \"lr\" ? \"vertical-lr\" : \"vertical-rl\"\n      );\n      if (!cue.style?.[\"--cue-width\"]) {\n        let maxSize = position;\n        if (positionAlignment === \"line-left\") {\n          maxSize = 100 - position;\n        } else if (positionAlignment === \"center\" && position <= 50) {\n          maxSize = position * 2;\n        } else if (positionAlignment === \"center\" && position > 50) {\n          maxSize = (100 - position) * 2;\n        }\n        const size = cue.size < maxSize ? cue.size : maxSize;\n        if (cue.vertical === \"\")\n          setCSSVar(display, \"cue-width\", size + \"%\");\n        else\n          setCSSVar(display, \"cue-height\", size + \"%\");\n      }\n    } else {\n      setCSSVar(\n        display,\n        \"cue-offset\",\n        `${position - (positionAlignment === \"line-right\" ? 100 : positionAlignment === \"center\" ? 50 : 0)}%`\n      );\n    }\n    const el = document.createElement(\"div\");\n    setPartAttr(el, \"cue\");\n    if (cue.id)\n      setDataAttr(el, \"id\", cue.id);\n    el.innerHTML = renderVTTCueString(cue);\n    display.append(el);\n    return display;\n  }\n  _hasRegion(cue) {\n    return cue.region && cue.size === 100 && cue.vertical === \"\" && cue.line === \"auto\";\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jYXB0aW9ucy9kaXN0L2Rldi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxUUFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFRQUF5QjtBQUNsRDtBQUNBO0FBQ0EsOERBQThELG1CQUFtQjtBQUNqRjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVcsMENBQTBDLFdBQVc7QUFDekg7QUFDQSxPQUFPO0FBQ1A7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsUUFBUTtBQUNSLE9BQU87QUFDUCxPQUFPO0FBQ1AsU0FBUztBQUNULFFBQVE7QUFDUixTQUFTO0FBQ1QsUUFBUTtBQUNSLFFBQVE7QUFDUixDQUFDLDhEQUE4RDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1C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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdHQUFnRztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVkaWEtY2FwdGlvbnMvZGlzdC9kZXYvaW5kZXguanM/NWMyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBQYXJzZUVycm9yQ29kZSA9IHtcbiAgTG9hZEZhaWw6IDAsXG4gIEJhZFNpZ25hdHVyZTogMSxcbiAgQmFkVGltZXN0YW1wOiAyLFxuICBCYWRTZXR0aW5nVmFsdWU6IDMsXG4gIEJhZEZvcm1hdDogNCxcbiAgVW5rbm93blNldHRpbmc6IDVcbn07XG5jbGFzcyBQYXJzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb2RlO1xuICBsaW5lO1xuICBjb25zdHJ1Y3Rvcihpbml0KSB7XG4gICAgc3VwZXIoaW5pdC5yZWFzb24pO1xuICAgIHRoaXMuY29kZSA9IGluaXQuY29kZTtcbiAgICB0aGlzLmxpbmUgPSBpbml0LmxpbmU7XG4gIH1cbn1cblxuY29uc3QgTElORV9URVJNSU5BVE9SX1JFID0gL1xccj9cXG58XFxyL2dtO1xuY2xhc3MgVGV4dExpbmVUcmFuc2Zvcm1TdHJlYW0ge1xuICB3cml0YWJsZTtcbiAgcmVhZGFibGU7XG4gIGNvbnN0cnVjdG9yKGVuY29kaW5nKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZXIgPSBuZXcgVGV4dFN0cmVhbUxpbmVJdGVyYXRvcihlbmNvZGluZyk7XG4gICAgdGhpcy53cml0YWJsZSA9IG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICB3cml0ZShjaHVuaykge1xuICAgICAgICB0cmFuc2Zvcm1lci50cmFuc2Zvcm0oY2h1bmspO1xuICAgICAgfSxcbiAgICAgIGNsb3NlKCkge1xuICAgICAgICB0cmFuc2Zvcm1lci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmVhZGFibGUgPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICB0cmFuc2Zvcm1lci5vbkxpbmUgPSAobGluZSkgPT4gY29udHJvbGxlci5lbnF1ZXVlKGxpbmUpO1xuICAgICAgICB0cmFuc2Zvcm1lci5vbkNsb3NlID0gKCkgPT4gY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBUZXh0U3RyZWFtTGluZUl0ZXJhdG9yIHtcbiAgX2J1ZmZlciA9IFwiXCI7XG4gIF9kZWNvZGVyO1xuICBvbkxpbmU7XG4gIG9uQ2xvc2U7XG4gIGNvbnN0cnVjdG9yKGVuY29kaW5nKSB7XG4gICAgdGhpcy5fZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZyk7XG4gIH1cbiAgdHJhbnNmb3JtKGNodW5rKSB7XG4gICAgdGhpcy5fYnVmZmVyICs9IHRoaXMuX2RlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICBjb25zdCBsaW5lcyA9IHRoaXMuX2J1ZmZlci5zcGxpdChMSU5FX1RFUk1JTkFUT1JfUkUpO1xuICAgIHRoaXMuX2J1ZmZlciA9IGxpbmVzLnBvcCgpIHx8IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMub25MaW5lKGxpbmVzW2ldLnRyaW0oKSk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcilcbiAgICAgIHRoaXMub25MaW5lKHRoaXMuX2J1ZmZlci50cmltKCkpO1xuICAgIHRoaXMuX2J1ZmZlciA9IFwiXCI7XG4gICAgdGhpcy5vbkNsb3NlKCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcGFyc2VUZXh0KHRleHQsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoTElORV9URVJNSU5BVE9SX1JFKTtcbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcylcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGxpbmUpO1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwYXJzZVRleHRTdHJlYW0oc3RyZWFtLCBvcHRpb25zKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlVGV4dFN0cmVhbShzdHJlYW0sIG9wdGlvbnMpIHtcbiAgY29uc3QgdHlwZSA9IG9wdGlvbnM/LnR5cGUgPz8gXCJ2dHRcIjtcbiAgbGV0IGZhY3Rvcnk7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcInNydFwiOlxuICAgICAgICBmYWN0b3J5ID0gKGF3YWl0IGltcG9ydCgnLi9zcnQtcGFyc2VyLmpzJykpLmRlZmF1bHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNzYVwiOlxuICAgICAgY2FzZSBcImFzc1wiOlxuICAgICAgICBmYWN0b3J5ID0gKGF3YWl0IGltcG9ydCgnLi9zc2EtcGFyc2VyLmpzJykpLmRlZmF1bHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZmFjdG9yeSA9IChhd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZ0dFBhcnNlcjsgfSkpLmRlZmF1bHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZhY3RvcnkgPSB0eXBlO1xuICB9XG4gIGxldCByZXN1bHQ7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKSwgcGFyc2VyID0gZmFjdG9yeSgpLCBlcnJvcnMgPSBvcHRpb25zPy5lcnJvcnMgIT09IGZhbHNlIHx8ICEhb3B0aW9ucz8uc3RyaWN0IHx8ICEhb3B0aW9ucz8uZXJyb3JzO1xuICBhd2FpdCBwYXJzZXIuaW5pdCh7XG4gICAgc3RyaWN0OiBmYWxzZSxcbiAgICAuLi5vcHRpb25zLFxuICAgIGVycm9ycyxcbiAgICB0eXBlLFxuICAgIGNhbmNlbCgpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgIHJlc3VsdCA9IHBhcnNlci5kb25lKHRydWUpO1xuICAgIH1cbiAgfSk7XG4gIGxldCBpID0gMTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBwYXJzZXIucGFyc2UoXCJcIiwgaSk7XG4gICAgICByZXN1bHQgPSBwYXJzZXIuZG9uZShmYWxzZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGFyc2VyLnBhcnNlKHZhbHVlLCBpKTtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcGFyc2VSZXNwb25zZShyZXNwb25zZSwgb3B0aW9ucykge1xuICBjb25zdCByZXMgPSBhd2FpdCByZXNwb25zZTtcbiAgaWYgKCFyZXMub2sgfHwgIXJlcy5ib2R5KSB7XG4gICAgbGV0IGVycm9yO1xuICAgIHtcbiAgICAgIGVycm9yID0gbmV3IFBhcnNlRXJyb3Ioe1xuICAgICAgICBjb2RlOiBQYXJzZUVycm9yQ29kZS5Mb2FkRmFpbCxcbiAgICAgICAgcmVhc29uOiAhcmVzLm9rID8gYHJlc3BvbnNlIGlzIG5vdCBvayAoc3RhdHVzOiAke3Jlcy5zdGF0dXN9KWAgOiBgcmVzcG9uc2UgYm9keSBpcyBtaXNzaW5nIChzdGF0dXM6ICR7cmVzLnN0YXR1c30pYCxcbiAgICAgICAgbGluZTogLTFcbiAgICAgIH0pO1xuICAgICAgb3B0aW9ucz8ub25FcnJvcj8uKGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgIGN1ZXM6IFtdLFxuICAgICAgcmVnaW9uczogW10sXG4gICAgICBlcnJvcnM6IFtlcnJvcl1cbiAgICB9O1xuICB9XG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwiXCIsIHR5cGUgPSBjb250ZW50VHlwZS5tYXRjaCgvdGV4dFxcLyguKj8pKD86O3wkKS8pPy5bMV0sIGVuY29kaW5nID0gY29udGVudFR5cGUubWF0Y2goL2NoYXJzZXQ9KC4qPykoPzo7fCQpLyk/LlsxXTtcbiAgcmV0dXJuIHBhcnNlQnl0ZVN0cmVhbShyZXMuYm9keSwgeyB0eXBlLCBlbmNvZGluZywgLi4ub3B0aW9ucyB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlQnl0ZVN0cmVhbShzdHJlYW0sIHsgZW5jb2RpbmcgPSBcInV0Zi04XCIsIC4uLm9wdGlvbnMgfSA9IHt9KSB7XG4gIGNvbnN0IHRleHRTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRMaW5lVHJhbnNmb3JtU3RyZWFtKGVuY29kaW5nKSk7XG4gIHJldHVybiBwYXJzZVRleHRTdHJlYW0odGV4dFN0cmVhbSwgb3B0aW9ucyk7XG59XG5cbmNsYXNzIFRleHRDdWUgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIC8qKlxuICAgKiBBIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhlIGN1ZS5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RleHRUcmFja0N1ZS9pZH1cbiAgICovXG4gIGlkID0gXCJcIjtcbiAgLyoqXG4gICAqIEEgYGRvdWJsZWAgdGhhdCByZXByZXNlbnRzIHRoZSB2aWRlbyB0aW1lIHRoYXQgdGhlIGN1ZSB3aWxsIHN0YXJ0IGJlaW5nIGRpc3BsYXllZCwgaW4gc2Vjb25kcy5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RleHRUcmFja0N1ZS9zdGFydFRpbWV9XG4gICAqL1xuICBzdGFydFRpbWU7XG4gIC8qKlxuICAgKiBBIGBkb3VibGVgIHRoYXQgcmVwcmVzZW50cyB0aGUgdmlkZW8gdGltZSB0aGF0IHRoZSBjdWUgd2lsbCBzdG9wIGJlaW5nIGRpc3BsYXllZCwgaW4gc2Vjb25kcy5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RleHRUcmFja0N1ZS9lbmRUaW1lfVxuICAgKi9cbiAgZW5kVGltZTtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIGN1ZS5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1ZUVEN1ZS90ZXh0fVxuICAgKi9cbiAgdGV4dDtcbiAgLyoqXG4gICAqIEEgYGJvb2xlYW5gIGZvciB3aGV0aGVyIHRoZSB2aWRlbyB3aWxsIHBhdXNlIHdoZW4gdGhpcyBjdWUgc3RvcHMgYmVpbmcgZGlzcGxheWVkLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGV4dFRyYWNrQ3VlL3BhdXNlT25FeGl0fVxuICAgKi9cbiAgcGF1c2VPbkV4aXQgPSBmYWxzZTtcbiAgY29uc3RydWN0b3Ioc3RhcnRUaW1lLCBlbmRUaW1lLCB0ZXh0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICB0aGlzLmVuZFRpbWUgPSBlbmRUaW1lO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHN1cGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBzdXBlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgfVxufVxuXG5jb25zdCBJU19TRVJWRVIgPSB0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCI7XG5cbmNvbnN0IEN1ZUJhc2UgPSBJU19TRVJWRVIgPyBUZXh0Q3VlIDogd2luZG93LlZUVEN1ZTtcbmNsYXNzIFZUVEN1ZSBleHRlbmRzIEN1ZUJhc2Uge1xuICAvKipcbiAgICogQSBgVlRUUmVnaW9uYCBvYmplY3QgZGVzY3JpYmluZyB0aGUgdmlkZW8ncyBzdWItcmVnaW9uIHRoYXQgdGhlIGN1ZSB3aWxsIGJlIGRyYXduIG9udG8sXG4gICAqIG9yIGBudWxsYCBpZiBub25lIGlzIGFzc2lnbmVkLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVlRUQ3VlL3JlZ2lvbn1cbiAgICovXG4gIHJlZ2lvbiA9IG51bGw7XG4gIC8qKlxuICAgKiBUaGUgY3VlIHdyaXRpbmcgZGlyZWN0aW9uLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVlRUQ3VlL3ZlcnRpY2FsfVxuICAgKi9cbiAgdmVydGljYWwgPSBcIlwiO1xuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGBWVFRDdWUubGluZWAgYXR0cmlidXRlIGlzIGFuIGludGVnZXIgbnVtYmVyIG9mIGxpbmVzIG9yIGEgcGVyY2VudGFnZVxuICAgKiBvZiB0aGUgdmlkZW8gc2l6ZS5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1ZUVEN1ZS9zbmFwVG9MaW5lc31cbiAgICovXG4gIHNuYXBUb0xpbmVzID0gdHJ1ZTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpbmUgcG9zaXRpb25pbmcgb2YgdGhlIGN1ZS4gVGhpcyBjYW4gYmUgdGhlIHN0cmluZyBgJ2F1dG8nYCBvciBhIG51bWJlciB3aG9zZVxuICAgKiBpbnRlcnByZXRhdGlvbiBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBgVlRUQ3VlLnNuYXBUb0xpbmVzYC5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1ZUVEN1ZS9saW5lfVxuICAgKi9cbiAgbGluZSA9IFwiYXV0b1wiO1xuICAvKipcbiAgICogUmV0dXJucyBhbiBlbnVtIHJlcHJlc2VudGluZyB0aGUgYWxpZ25tZW50IG9mIHRoZSBgVlRUQ3VlLmxpbmVgLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVlRUQ3VlL2xpbmVBbGlnbn1cbiAgICovXG4gIGxpbmVBbGlnbiA9IFwic3RhcnRcIjtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBjdWUgd2l0aGluIHRoZSBsaW5lLiBUaGlzIGNhbiBiZSB0aGUgc3RyaW5nIGAnYXV0bydgIG9yIGFcbiAgICogbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgcGVyY2VudGFnZSBvZiB0aGUgYFZUVEN1ZS5yZWdpb25gLCBvciB0aGUgdmlkZW8gc2l6ZSBpZiBgVlRUQ3VlYC5yZWdpb25gXG4gICAqIGlzIGBudWxsYC5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1ZUVEN1ZS9wb3NpdGlvbn1cbiAgICovXG4gIHBvc2l0aW9uID0gXCJhdXRvXCI7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVudW0gcmVwcmVzZW50aW5nIHRoZSBhbGlnbm1lbnQgb2YgdGhlIGN1ZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSB3aGF0XG4gICAqIHRoZSBgVlRUQ3VlLnBvc2l0aW9uYCBpcyBhbmNob3JlZCB0by4gVGhlIGRlZmF1bHQgaXMgYCdhdXRvJ2AuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9WVFRDdWUvcG9zaXRpb25BbGlnbn1cbiAgICovXG4gIHBvc2l0aW9uQWxpZ24gPSBcImF1dG9cIjtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBkb3VibGUgcmVwcmVzZW50aW5nIHRoZSBzaXplIG9mIHRoZSBjdWUsIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgdmlkZW8gc2l6ZS5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1ZUVEN1ZS9zaXplfVxuICAgKi9cbiAgc2l6ZSA9IDEwMDtcbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZW51bSByZXByZXNlbnRpbmcgdGhlIGFsaWdubWVudCBvZiBhbGwgdGhlIGxpbmVzIG9mIHRleHQgd2l0aGluIHRoZSBjdWUgYm94LlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVlRUQ3VlL2FsaWdufVxuICAgKi9cbiAgYWxpZ24gPSBcImNlbnRlclwiO1xuICAvKipcbiAgICogQWRkaXRpb25hbCBzdHlsZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdWUuXG4gICAqL1xuICBzdHlsZTtcbn1cblxuY2xhc3MgVlRUUmVnaW9uIHtcbiAgLyoqXG4gICAqIEEgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGUgcmVnaW9uLlxuICAgKi9cbiAgaWQgPSBcIlwiO1xuICAvKipcbiAgICogQSBgZG91YmxlYCByZXByZXNlbnRpbmcgdGhlIHdpZHRoIG9mIHRoZSByZWdpb24sIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgdmlkZW8uXG4gICAqL1xuICB3aWR0aCA9IDEwMDtcbiAgLyoqXG4gICAqIEEgYGRvdWJsZWAgcmVwcmVzZW50aW5nIHRoZSBoZWlnaHQgb2YgdGhlIHJlZ2lvbiwgaW4gbnVtYmVyIG9mIGxpbmVzLlxuICAgKi9cbiAgbGluZXMgPSAzO1xuICAvKipcbiAgICogQSBgZG91YmxlYCByZXByZXNlbnRpbmcgdGhlIHJlZ2lvbiBhbmNob3IgWCBvZmZzZXQsIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgcmVnaW9uLlxuICAgKi9cbiAgcmVnaW9uQW5jaG9yWCA9IDA7XG4gIC8qKlxuICAgKiBBIGBkb3VibGVgIHJlcHJlc2VudGluZyB0aGUgcmVnaW9uIGFuY2hvciBZIG9mZnNldCwgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSByZWdpb24uXG4gICAqL1xuICByZWdpb25BbmNob3JZID0gMTAwO1xuICAvKipcbiAgICogQSBgZG91YmxlYCByZXByZXNlbnRpbmcgdGhlIHZpZXdwb3J0IGFuY2hvciBYIG9mZnNldCwgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSB2aWRlby5cbiAgICovXG4gIHZpZXdwb3J0QW5jaG9yWCA9IDA7XG4gIC8qKlxuICAgKiBBIGBkb3VibGVgIHJlcHJlc2VudGluZyB0aGUgdmlld3BvcnQgYW5jaG9yIFkgb2Zmc2V0LCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHZpZGVvLlxuICAgKi9cbiAgdmlld3BvcnRBbmNob3JZID0gMTAwO1xuICAvKipcbiAgICogQW4gZW51bSByZXByZXNlbnRpbmcgaG93IGFkZGluZyBuZXcgY3VlcyB3aWxsIG1vdmUgZXhpc3RpbmcgY3Vlcy5cbiAgICovXG4gIHNjcm9sbCA9IFwiXCI7XG59XG5cbmNvbnN0IENPTU1BJDEgPSBcIixcIiwgUEVSQ0VOVF9TSUdOJDEgPSBcIiVcIjtcbmZ1bmN0aW9uIHRvTnVtYmVyKHRleHQpIHtcbiAgY29uc3QgbnVtID0gcGFyc2VJbnQodGV4dCwgMTApO1xuICByZXR1cm4gIU51bWJlci5pc05hTihudW0pID8gbnVtIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHRvUGVyY2VudGFnZSh0ZXh0KSB7XG4gIGNvbnN0IG51bSA9IHBhcnNlSW50KHRleHQucmVwbGFjZShQRVJDRU5UX1NJR04kMSwgXCJcIiksIDEwKTtcbiAgcmV0dXJuICFOdW1iZXIuaXNOYU4obnVtKSAmJiBudW0gPj0gMCAmJiBudW0gPD0gMTAwID8gbnVtIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHRvQ29vcmRzKHRleHQpIHtcbiAgaWYgKCF0ZXh0LmluY2x1ZGVzKENPTU1BJDEpKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBbeCwgeV0gPSB0ZXh0LnNwbGl0KENPTU1BJDEpLm1hcCh0b1BlcmNlbnRhZ2UpO1xuICByZXR1cm4geCAhPT0gbnVsbCAmJiB5ICE9PSBudWxsID8gW3gsIHldIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHRvRmxvYXQodGV4dCkge1xuICBjb25zdCBudW0gPSBwYXJzZUZsb2F0KHRleHQpO1xuICByZXR1cm4gIU51bWJlci5pc05hTihudW0pID8gbnVtIDogbnVsbDtcbn1cblxuY29uc3QgSEVBREVSX01BR0lDID0gXCJXRUJWVFRcIiwgQ09NTUEgPSBcIixcIiwgUEVSQ0VOVF9TSUdOID0gXCIlXCIsIFNFVFRJTkdfU0VQX1JFID0gL1s6PV0vLCBTRVRUSU5HX0xJTkVfUkUgPSAvXltcXHNcXHRdKihyZWdpb258dmVydGljYWx8bGluZXxwb3NpdGlvbnxzaXplfGFsaWduKVs6PV0vLCBOT1RFX0JMT0NLX1NUQVJUID0gXCJOT1RFXCIsIFJFR0lPTl9CTE9DS19TVEFSVCA9IFwiUkVHSU9OXCIsIFJFR0lPTl9CTE9DS19TVEFSVF9SRSA9IC9eUkVHSU9OOj9bXFxzXFx0XSsvLCBTUEFDRV9SRSA9IC9bXFxzXFx0XSsvLCBUSU1FU1RBTVBfU0VQID0gXCItLT5cIiwgVElNRVNUQU1QX1NFUF9SRSA9IC9bXFxzXFx0XSotLT5bXFxzXFx0XSsvLCBBTElHTl9SRSA9IC9zdGFydHxjZW50ZXJ8ZW5kfGxlZnR8cmlnaHQvLCBMSU5FX0FMSUdOX1JFID0gL3N0YXJ0fGNlbnRlcnxlbmQvLCBQT1NfQUxJR05fUkUgPSAvbGluZS0oPzpsZWZ0fHJpZ2h0KXxjZW50ZXJ8YXV0by8sIFRJTUVTVEFNUF9SRSA9IC9eKD86KFxcZHsxLDJ9KTopPyhcXGR7Mn0pOihcXGR7Mn0pKD86XFwuKFxcZHsxLDN9KSk/JC87XG52YXIgVlRUQmxvY2sgPSAvKiBAX19QVVJFX18gKi8gKChWVFRCbG9jazIpID0+IHtcbiAgVlRUQmxvY2syW1ZUVEJsb2NrMltcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICBWVFRCbG9jazJbVlRUQmxvY2syW1wiSGVhZGVyXCJdID0gMV0gPSBcIkhlYWRlclwiO1xuICBWVFRCbG9jazJbVlRUQmxvY2syW1wiQ3VlXCJdID0gMl0gPSBcIkN1ZVwiO1xuICBWVFRCbG9jazJbVlRUQmxvY2syW1wiUmVnaW9uXCJdID0gM10gPSBcIlJlZ2lvblwiO1xuICBWVFRCbG9jazJbVlRUQmxvY2syW1wiTm90ZVwiXSA9IDRdID0gXCJOb3RlXCI7XG4gIHJldHVybiBWVFRCbG9jazI7XG59KShWVFRCbG9jayB8fCB7fSk7XG5jbGFzcyBWVFRQYXJzZXIge1xuICBfaW5pdDtcbiAgX2Jsb2NrID0gMCAvKiBOb25lICovO1xuICBfbWV0YWRhdGEgPSB7fTtcbiAgX3JlZ2lvbnMgPSB7fTtcbiAgX2N1ZXMgPSBbXTtcbiAgX2N1ZSA9IG51bGw7XG4gIF9yZWdpb24gPSBudWxsO1xuICBfZXJyb3JzID0gW107XG4gIF9lcnJvckJ1aWxkZXI7XG4gIF9wcmV2TGluZSA9IFwiXCI7XG4gIGFzeW5jIGluaXQoaW5pdCkge1xuICAgIHRoaXMuX2luaXQgPSBpbml0O1xuICAgIGlmIChpbml0LnN0cmljdClcbiAgICAgIHRoaXMuX2Jsb2NrID0gMSAvKiBIZWFkZXIgKi87XG4gICAgaWYgKGluaXQuZXJyb3JzKVxuICAgICAgdGhpcy5fZXJyb3JCdWlsZGVyID0gKGF3YWl0IGltcG9ydCgnLi9lcnJvcnMuanMnKSkuUGFyc2VFcnJvckJ1aWxkZXI7XG4gIH1cbiAgcGFyc2UobGluZSwgbGluZUNvdW50KSB7XG4gICAgaWYgKGxpbmUgPT09IFwiXCIpIHtcbiAgICAgIGlmICh0aGlzLl9jdWUpIHtcbiAgICAgICAgdGhpcy5fY3Vlcy5wdXNoKHRoaXMuX2N1ZSk7XG4gICAgICAgIHRoaXMuX2luaXQub25DdWU/Lih0aGlzLl9jdWUpO1xuICAgICAgICB0aGlzLl9jdWUgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9yZWdpb24pIHtcbiAgICAgICAgdGhpcy5fcmVnaW9uc1t0aGlzLl9yZWdpb24uaWRdID0gdGhpcy5fcmVnaW9uO1xuICAgICAgICB0aGlzLl9pbml0Lm9uUmVnaW9uPy4odGhpcy5fcmVnaW9uKTtcbiAgICAgICAgdGhpcy5fcmVnaW9uID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmxvY2sgPT09IDEgLyogSGVhZGVyICovKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlSGVhZGVyKGxpbmUsIGxpbmVDb3VudCk7XG4gICAgICAgIHRoaXMuX2luaXQub25IZWFkZXJNZXRhZGF0YT8uKHRoaXMuX21ldGFkYXRhKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Jsb2NrID0gMCAvKiBOb25lICovO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fYmxvY2spIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fYmxvY2spIHtcbiAgICAgICAgY2FzZSAxIC8qIEhlYWRlciAqLzpcbiAgICAgICAgICB0aGlzLl9wYXJzZUhlYWRlcihsaW5lLCBsaW5lQ291bnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogQ3VlICovOlxuICAgICAgICAgIGlmICh0aGlzLl9jdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc1RleHQgPSB0aGlzLl9jdWUudGV4dC5sZW5ndGggPiAwO1xuICAgICAgICAgICAgaWYgKCFoYXNUZXh0ICYmIFNFVFRJTkdfTElORV9SRS50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3BhcnNlQ3VlU2V0dGluZ3MobGluZS5zcGxpdChTUEFDRV9SRSksIGxpbmVDb3VudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9jdWUudGV4dCArPSAoaGFzVGV4dCA/IFwiXFxuXCIgOiBcIlwiKSArIGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMgLyogUmVnaW9uICovOlxuICAgICAgICAgIHRoaXMuX3BhcnNlUmVnaW9uU2V0dGluZ3MobGluZS5zcGxpdChTUEFDRV9SRSksIGxpbmVDb3VudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoTk9URV9CTE9DS19TVEFSVCkpIHtcbiAgICAgIHRoaXMuX2Jsb2NrID0gNCAvKiBOb3RlICovO1xuICAgIH0gZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKFJFR0lPTl9CTE9DS19TVEFSVCkpIHtcbiAgICAgIHRoaXMuX2Jsb2NrID0gMyAvKiBSZWdpb24gKi87XG4gICAgICB0aGlzLl9yZWdpb24gPSBuZXcgVlRUUmVnaW9uKCk7XG4gICAgICB0aGlzLl9wYXJzZVJlZ2lvblNldHRpbmdzKGxpbmUucmVwbGFjZShSRUdJT05fQkxPQ0tfU1RBUlRfUkUsIFwiXCIpLnNwbGl0KFNQQUNFX1JFKSwgbGluZUNvdW50KTtcbiAgICB9IGVsc2UgaWYgKGxpbmUuaW5jbHVkZXMoVElNRVNUQU1QX1NFUCkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlVGltZXN0YW1wKGxpbmUsIGxpbmVDb3VudCk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHRoaXMuX2N1ZSA9IG5ldyBWVFRDdWUocmVzdWx0WzBdLCByZXN1bHRbMV0sIFwiXCIpO1xuICAgICAgICB0aGlzLl9jdWUuaWQgPSB0aGlzLl9wcmV2TGluZTtcbiAgICAgICAgdGhpcy5fcGFyc2VDdWVTZXR0aW5ncyhyZXN1bHRbMl0sIGxpbmVDb3VudCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ibG9jayA9IDIgLyogQ3VlICovO1xuICAgIH0gZWxzZSBpZiAobGluZUNvdW50ID09PSAxKSB7XG4gICAgICB0aGlzLl9wYXJzZUhlYWRlcihsaW5lLCBsaW5lQ291bnQpO1xuICAgIH1cbiAgICB0aGlzLl9wcmV2TGluZSA9IGxpbmU7XG4gIH1cbiAgZG9uZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWV0YWRhdGE6IHRoaXMuX21ldGFkYXRhLFxuICAgICAgY3VlczogdGhpcy5fY3VlcyxcbiAgICAgIHJlZ2lvbnM6IE9iamVjdC52YWx1ZXModGhpcy5fcmVnaW9ucyksXG4gICAgICBlcnJvcnM6IHRoaXMuX2Vycm9yc1xuICAgIH07XG4gIH1cbiAgX3BhcnNlSGVhZGVyKGxpbmUsIGxpbmVDb3VudCkge1xuICAgIGlmIChsaW5lQ291bnQgPiAxKSB7XG4gICAgICBpZiAoU0VUVElOR19TRVBfUkUudGVzdChsaW5lKSkge1xuICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBsaW5lLnNwbGl0KFNFVFRJTkdfU0VQX1JFKTtcbiAgICAgICAgaWYgKGtleSlcbiAgICAgICAgICB0aGlzLl9tZXRhZGF0YVtrZXldID0gKHZhbHVlIHx8IFwiXCIpLnJlcGxhY2UoU1BBQ0VfUkUsIFwiXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKEhFQURFUl9NQUdJQykpIHtcbiAgICAgIHRoaXMuX2Jsb2NrID0gMSAvKiBIZWFkZXIgKi87XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hhbmRsZUVycm9yKHRoaXMuX2Vycm9yQnVpbGRlcj8uX2JhZFZUVEhlYWRlcigpKTtcbiAgICB9XG4gIH1cbiAgX3BhcnNlVGltZXN0YW1wKGxpbmUsIGxpbmVDb3VudCkge1xuICAgIGNvbnN0IFtzdGFydFRpbWVUZXh0LCB0cmFpbGluZ1RleHQgPSBcIlwiXSA9IGxpbmUuc3BsaXQoVElNRVNUQU1QX1NFUF9SRSksIFtlbmRUaW1lVGV4dCwgLi4uc2V0dGluZ3NUZXh0XSA9IHRyYWlsaW5nVGV4dC5zcGxpdChTUEFDRV9SRSksIHN0YXJ0VGltZSA9IHBhcnNlVlRUVGltZXN0YW1wKHN0YXJ0VGltZVRleHQpLCBlbmRUaW1lID0gcGFyc2VWVFRUaW1lc3RhbXAoZW5kVGltZVRleHQpO1xuICAgIGlmIChzdGFydFRpbWUgIT09IG51bGwgJiYgZW5kVGltZSAhPT0gbnVsbCAmJiBlbmRUaW1lID4gc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gW3N0YXJ0VGltZSwgZW5kVGltZSwgc2V0dGluZ3NUZXh0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVFcnJvcih0aGlzLl9lcnJvckJ1aWxkZXI/Ll9iYWRTdGFydFRpbWVzdGFtcChzdGFydFRpbWVUZXh0LCBsaW5lQ291bnQpKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmRUaW1lID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUVycm9yKHRoaXMuX2Vycm9yQnVpbGRlcj8uX2JhZEVuZFRpbWVzdGFtcChlbmRUaW1lVGV4dCwgbGluZUNvdW50KSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnRUaW1lICE9IG51bGwgJiYgZW5kVGltZSAhPT0gbnVsbCAmJiBlbmRUaW1lID4gc3RhcnRUaW1lKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUVycm9yKHRoaXMuX2Vycm9yQnVpbGRlcj8uX2JhZFJhbmdlVGltZXN0YW1wKHN0YXJ0VGltZSwgZW5kVGltZSwgbGluZUNvdW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvd2VidnR0MS8jcmVnaW9uLXNldHRpbmdzLXBhcnNpbmd9XG4gICAqL1xuICBfcGFyc2VSZWdpb25TZXR0aW5ncyhzZXR0aW5ncywgbGluZSkge1xuICAgIGxldCBiYWRWYWx1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoU0VUVElOR19TRVBfUkUudGVzdChzZXR0aW5nc1tpXSkpIHtcbiAgICAgICAgYmFkVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgW25hbWUsIHZhbHVlXSA9IHNldHRpbmdzW2ldLnNwbGl0KFNFVFRJTkdfU0VQX1JFKTtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgICAgICB0aGlzLl9yZWdpb24uaWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0b1BlcmNlbnRhZ2UodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHdpZHRoICE9PSBudWxsKVxuICAgICAgICAgICAgICB0aGlzLl9yZWdpb24ud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYmFkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImxpbmVzXCI6XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChsaW5lcyAhPT0gbnVsbClcbiAgICAgICAgICAgICAgdGhpcy5fcmVnaW9uLmxpbmVzID0gbGluZXM7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGJhZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJyZWdpb25hbmNob3JcIjpcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvbiA9IHRvQ29vcmRzKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZWdpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVnaW9uLnJlZ2lvbkFuY2hvclggPSByZWdpb25bMF07XG4gICAgICAgICAgICAgIHRoaXMuX3JlZ2lvbi5yZWdpb25BbmNob3JZID0gcmVnaW9uWzFdO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGJhZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ2aWV3cG9ydGFuY2hvclwiOlxuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSB0b0Nvb3Jkcyh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmlld3BvcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVnaW9uLnZpZXdwb3J0QW5jaG9yWCA9IHZpZXdwb3J0WzBdO1xuICAgICAgICAgICAgICB0aGlzLl9yZWdpb24udmlld3BvcnRBbmNob3JZID0gdmlld3BvcnRbMV07XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgYmFkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInNjcm9sbFwiOlxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcInVwXCIpXG4gICAgICAgICAgICAgIHRoaXMuX3JlZ2lvbi5zY3JvbGwgPSBcInVwXCI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGJhZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVFcnJvcih0aGlzLl9lcnJvckJ1aWxkZXI/Ll91bmtub3duUmVnaW9uU2V0dGluZyhuYW1lLCB2YWx1ZSwgbGluZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYWRWYWx1ZSkge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yKHRoaXMuX2Vycm9yQnVpbGRlcj8uX2JhZFJlZ2lvblNldHRpbmcobmFtZSwgdmFsdWUsIGxpbmUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYnZ0dDEvI2N1ZS10aW1pbmdzLWFuZC1zZXR0aW5ncy1wYXJzaW5nfVxuICAgKi9cbiAgX3BhcnNlQ3VlU2V0dGluZ3Moc2V0dGluZ3MsIGxpbmUpIHtcbiAgICBsZXQgYmFkVmFsdWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXR0aW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgYmFkVmFsdWUgPSBmYWxzZTtcbiAgICAgIGlmIChTRVRUSU5HX1NFUF9SRS50ZXN0KHNldHRpbmdzW2ldKSkge1xuICAgICAgICBjb25zdCBbbmFtZSwgdmFsdWVdID0gc2V0dGluZ3NbaV0uc3BsaXQoU0VUVElOR19TRVBfUkUpO1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwicmVnaW9uXCI6XG4gICAgICAgICAgICBjb25zdCByZWdpb24gPSB0aGlzLl9yZWdpb25zW3ZhbHVlXTtcbiAgICAgICAgICAgIGlmIChyZWdpb24pXG4gICAgICAgICAgICAgIHRoaXMuX2N1ZS5yZWdpb24gPSByZWdpb247XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJsclwiIHx8IHZhbHVlID09PSBcInJsXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3VlLnZlcnRpY2FsID0gdmFsdWU7XG4gICAgICAgICAgICAgIHRoaXMuX2N1ZS5yZWdpb24gPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGJhZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJsaW5lXCI6XG4gICAgICAgICAgICBjb25zdCBbbGluZVBvcywgbGluZUFsaWduXSA9IHZhbHVlLnNwbGl0KENPTU1BKTtcbiAgICAgICAgICAgIGlmIChsaW5lUG9zLmluY2x1ZGVzKFBFUkNFTlRfU0lHTikpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHRvUGVyY2VudGFnZShsaW5lUG9zKTtcbiAgICAgICAgICAgICAgaWYgKHBlcmNlbnRhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdWUubGluZSA9IHBlcmNlbnRhZ2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VlLnNuYXBUb0xpbmVzID0gZmFsc2U7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGJhZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IG51bWJlciA9IHRvRmxvYXQobGluZVBvcyk7XG4gICAgICAgICAgICAgIGlmIChudW1iZXIgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VlLmxpbmUgPSBudW1iZXI7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBiYWRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTElORV9BTElHTl9SRS50ZXN0KGxpbmVBbGlnbikpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3VlLmxpbmVBbGlnbiA9IGxpbmVBbGlnbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZUFsaWduKSB7XG4gICAgICAgICAgICAgIGJhZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9jdWUubGluZSAhPT0gXCJhdXRvXCIpXG4gICAgICAgICAgICAgIHRoaXMuX2N1ZS5yZWdpb24gPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInBvc2l0aW9uXCI6XG4gICAgICAgICAgICBjb25zdCBbY29sUG9zLCBjb2xBbGlnbl0gPSB2YWx1ZS5zcGxpdChDT01NQSksIHBvc2l0aW9uID0gdG9QZXJjZW50YWdlKGNvbFBvcyk7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gIT09IG51bGwpXG4gICAgICAgICAgICAgIHRoaXMuX2N1ZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBiYWRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoY29sQWxpZ24gJiYgUE9TX0FMSUdOX1JFLnRlc3QoY29sQWxpZ24pKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1ZS5wb3NpdGlvbkFsaWduID0gY29sQWxpZ247XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbEFsaWduKSB7XG4gICAgICAgICAgICAgIGJhZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzaXplXCI6XG4gICAgICAgICAgICBjb25zdCBzaXplID0gdG9QZXJjZW50YWdlKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChzaXplICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1ZS5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgaWYgKHNpemUgPCAxMDApXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VlLnJlZ2lvbiA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBiYWRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYWxpZ25cIjpcbiAgICAgICAgICAgIGlmIChBTElHTl9SRS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICB0aGlzLl9jdWUuYWxpZ24gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJhZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVFcnJvcih0aGlzLl9lcnJvckJ1aWxkZXI/Ll91bmtub3duQ3VlU2V0dGluZyhuYW1lLCB2YWx1ZSwgbGluZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYWRWYWx1ZSkge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yKHRoaXMuX2Vycm9yQnVpbGRlcj8uX2JhZEN1ZVNldHRpbmcobmFtZSwgdmFsdWUsIGxpbmUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfaGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoIWVycm9yKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2Vycm9ycy5wdXNoKGVycm9yKTtcbiAgICBpZiAodGhpcy5faW5pdC5zdHJpY3QpIHtcbiAgICAgIHRoaXMuX2luaXQuY2FuY2VsKCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5pdC5vbkVycm9yPy4oZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VWVFRUaW1lc3RhbXAodGltZXN0YW1wKSB7XG4gIGNvbnN0IG1hdGNoID0gdGltZXN0YW1wLm1hdGNoKFRJTUVTVEFNUF9SRSk7XG4gIGlmICghbWF0Y2gpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGhvdXJzID0gbWF0Y2hbMV0gPyBwYXJzZUludChtYXRjaFsxXSwgMTApIDogMCwgbWludXRlcyA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCksIHNlY29uZHMgPSBwYXJzZUludChtYXRjaFszXSwgMTApLCBtaWxsaXNlY29uZHMgPSBtYXRjaFs0XSA/IHBhcnNlSW50KG1hdGNoWzRdLnBhZEVuZCgzLCBcIjBcIiksIDEwKSA6IDAsIHRvdGFsID0gaG91cnMgKiAzNjAwICsgbWludXRlcyAqIDYwICsgc2Vjb25kcyArIG1pbGxpc2Vjb25kcyAvIDFlMztcbiAgaWYgKGhvdXJzIDwgMCB8fCBtaW51dGVzIDwgMCB8fCBzZWNvbmRzIDwgMCB8fCBtaWxsaXNlY29uZHMgPCAwIHx8IG1pbnV0ZXMgPiA1OSB8fCBzZWNvbmRzID4gNTkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gdG90YWw7XG59XG5mdW5jdGlvbiBjcmVhdGVWVFRQYXJzZXIoKSB7XG4gIHJldHVybiBuZXcgVlRUUGFyc2VyKCk7XG59XG5cbnZhciB2dHRQYXJzZXIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgVlRUQmxvY2s6IFZUVEJsb2NrLFxuICBWVFRQYXJzZXI6IFZUVFBhcnNlcixcbiAgZGVmYXVsdDogY3JlYXRlVlRUUGFyc2VyLFxuICBwYXJzZVZUVFRpbWVzdGFtcDogcGFyc2VWVFRUaW1lc3RhbXBcbn0pO1xuXG5jb25zdCBESUdJVF9SRSA9IC9bMC05XS8sIE1VTFRJX1NQQUNFX1JFID0gL1tcXHNcXHRdKy8sIFRBR19OQU1FID0ge1xuICBjOiBcInNwYW5cIixcbiAgaTogXCJpXCIsXG4gIGI6IFwiYlwiLFxuICB1OiBcInVcIixcbiAgcnVieTogXCJydWJ5XCIsXG4gIHJ0OiBcInJ0XCIsXG4gIHY6IFwic3BhblwiLFxuICBsYW5nOiBcInNwYW5cIixcbiAgdGltZXN0YW1wOiBcInNwYW5cIlxufSwgSFRNTF9FTlRJVElFUyA9IHtcbiAgXCImYW1wO1wiOiBcIiZcIixcbiAgXCImbHQ7XCI6IFwiPFwiLFxuICBcIiZndDtcIjogXCI+XCIsXG4gIFwiJnF1b3Q7XCI6ICdcIicsXG4gIFwiJiMzOTtcIjogXCInXCIsXG4gIFwiJm5ic3A7XCI6IFwiXFx4QTBcIixcbiAgXCImbHJtO1wiOiBcIlxcdTIwMEVcIixcbiAgXCImcmxtO1wiOiBcIlxcdTIwMEZcIlxufSwgSFRNTF9FTlRJVFlfUkUgPSAvJig/OmFtcHxsdHxndHxxdW90fCMoMCspPzM5fG5ic3B8bHJtfHJsbSk7L2csIENPTE9SUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJ3aGl0ZVwiLFxuICBcImxpbWVcIixcbiAgXCJjeWFuXCIsXG4gIFwicmVkXCIsXG4gIFwieWVsbG93XCIsXG4gIFwibWFnZW50YVwiLFxuICBcImJsdWVcIixcbiAgXCJibGFja1wiXG5dKSwgQkxPQ0tfVFlQRVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChPYmplY3Qua2V5cyhUQUdfTkFNRSkpO1xuZnVuY3Rpb24gdG9rZW5pemVWVFRDdWUoY3VlKSB7XG4gIGxldCBidWZmZXIgPSBcIlwiLCBtb2RlID0gMSAvKiBEYXRhICovLCByZXN1bHQgPSBbXSwgc3RhY2sgPSBbXSwgbm9kZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdWUudGV4dC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBjdWUudGV4dFtpXTtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgIGNhc2UgMSAvKiBEYXRhICovOlxuICAgICAgICBpZiAoY2hhciA9PT0gXCI8XCIpIHtcbiAgICAgICAgICBhZGRUZXh0KCk7XG4gICAgICAgICAgbW9kZSA9IDIgLyogVGFnICovO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlciArPSBjaGFyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyIC8qIFRhZyAqLzpcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgIGNhc2UgXCJcdFwiOlxuICAgICAgICAgIGNhc2UgXCIgXCI6XG4gICAgICAgICAgICBhZGROb2RlKCk7XG4gICAgICAgICAgICBtb2RlID0gNCAvKiBBbm5vdGF0aW9uICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIi5cIjpcbiAgICAgICAgICAgIGFkZE5vZGUoKTtcbiAgICAgICAgICAgIG1vZGUgPSAzIC8qIENsYXNzICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgIG1vZGUgPSA1IC8qIEVuZFRhZyAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgICBhZGROb2RlKCk7XG4gICAgICAgICAgICBtb2RlID0gMSAvKiBEYXRhICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghYnVmZmVyICYmIERJR0lUX1JFLnRlc3QoY2hhcikpXG4gICAgICAgICAgICAgIG1vZGUgPSA2IC8qIFRpbWVzdGFtcCAqLztcbiAgICAgICAgICAgIGJ1ZmZlciArPSBjaGFyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDMgLyogQ2xhc3MgKi86XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCJcdFwiOlxuICAgICAgICAgIGNhc2UgXCIgXCI6XG4gICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgYWRkQ2xhc3MoKTtcbiAgICAgICAgICAgIGlmIChub2RlKVxuICAgICAgICAgICAgICBub2RlLmNsYXNzPy50cmltKCk7XG4gICAgICAgICAgICBtb2RlID0gNCAvKiBBbm5vdGF0aW9uICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIi5cIjpcbiAgICAgICAgICAgIGFkZENsYXNzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgYWRkQ2xhc3MoKTtcbiAgICAgICAgICAgIGlmIChub2RlKVxuICAgICAgICAgICAgICBub2RlLmNsYXNzPy50cmltKCk7XG4gICAgICAgICAgICBtb2RlID0gMSAvKiBEYXRhICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJ1ZmZlciArPSBjaGFyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0IC8qIEFubm90YXRpb24gKi86XG4gICAgICAgIGlmIChjaGFyID09PSBcIj5cIikge1xuICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5yZXBsYWNlKE1VTFRJX1NQQUNFX1JFLCBcIiBcIik7XG4gICAgICAgICAgaWYgKG5vZGU/LnR5cGUgPT09IFwidlwiKVxuICAgICAgICAgICAgbm9kZS52b2ljZSA9IHJlcGxhY2VIVE1MRW50aXRpZXMoYnVmZmVyKTtcbiAgICAgICAgICBlbHNlIGlmIChub2RlPy50eXBlID09PSBcImxhbmdcIilcbiAgICAgICAgICAgIG5vZGUubGFuZyA9IHJlcGxhY2VIVE1MRW50aXRpZXMoYnVmZmVyKTtcbiAgICAgICAgICBidWZmZXIgPSBcIlwiO1xuICAgICAgICAgIG1vZGUgPSAxIC8qIERhdGEgKi87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyICs9IGNoYXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDUgLyogRW5kVGFnICovOlxuICAgICAgICBpZiAoY2hhciA9PT0gXCI+XCIpIHtcbiAgICAgICAgICBidWZmZXIgPSBcIlwiO1xuICAgICAgICAgIG5vZGUgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICBtb2RlID0gMSAvKiBEYXRhICovO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2IC8qIFRpbWVzdGFtcCAqLzpcbiAgICAgICAgaWYgKGNoYXIgPT09IFwiPlwiKSB7XG4gICAgICAgICAgY29uc3QgdGltZSA9IHBhcnNlVlRUVGltZXN0YW1wKGJ1ZmZlcik7XG4gICAgICAgICAgaWYgKHRpbWUgIT09IG51bGwgJiYgdGltZSA+PSBjdWUuc3RhcnRUaW1lICYmIHRpbWUgPD0gY3VlLmVuZFRpbWUpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IFwidGltZXN0YW1wXCI7XG4gICAgICAgICAgICBhZGROb2RlKCk7XG4gICAgICAgICAgICBub2RlLnRpbWUgPSB0aW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXIgPSBcIlwiO1xuICAgICAgICAgIG1vZGUgPSAxIC8qIERhdGEgKi87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyICs9IGNoYXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFkZE5vZGUoKSB7XG4gICAgaWYgKEJMT0NLX1RZUEVTLmhhcyhidWZmZXIpKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlO1xuICAgICAgbm9kZSA9IGNyZWF0ZUJsb2NrTm9kZShidWZmZXIpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gIT09IHBhcmVudClcbiAgICAgICAgICBzdGFjay5wdXNoKHBhcmVudCk7XG4gICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBidWZmZXIgPSBcIlwiO1xuICAgIG1vZGUgPSAxIC8qIERhdGEgKi87XG4gIH1cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoKSB7XG4gICAgaWYgKG5vZGUgJiYgYnVmZmVyKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGJ1ZmZlci5yZXBsYWNlKFwiYmdfXCIsIFwiXCIpO1xuICAgICAgaWYgKENPTE9SUy5oYXMoY29sb3IpKSB7XG4gICAgICAgIG5vZGVbYnVmZmVyLnN0YXJ0c1dpdGgoXCJiZ19cIikgPyBcImJnQ29sb3JcIiA6IFwiY29sb3JcIl0gPSBjb2xvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuY2xhc3MgPSAhbm9kZS5jbGFzcyA/IGJ1ZmZlciA6IG5vZGUuY2xhc3MgKyBcIiBcIiArIGJ1ZmZlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmZmVyID0gXCJcIjtcbiAgfVxuICBmdW5jdGlvbiBhZGRUZXh0KCkge1xuICAgIGlmICghYnVmZmVyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHRleHQgPSB7IHR5cGU6IFwidGV4dFwiLCBkYXRhOiByZXBsYWNlSFRNTEVudGl0aWVzKGJ1ZmZlcikgfTtcbiAgICBub2RlID8gbm9kZS5jaGlsZHJlbi5wdXNoKHRleHQpIDogcmVzdWx0LnB1c2godGV4dCk7XG4gICAgYnVmZmVyID0gXCJcIjtcbiAgfVxuICBpZiAobW9kZSA9PT0gMSAvKiBEYXRhICovKVxuICAgIGFkZFRleHQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrTm9kZSh0eXBlKSB7XG4gIHJldHVybiB7XG4gICAgdGFnTmFtZTogVEFHX05BTUVbdHlwZV0sXG4gICAgdHlwZSxcbiAgICBjaGlsZHJlbjogW11cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VIVE1MRW50aXRpZXModGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKEhUTUxfRU5USVRZX1JFLCAoZW50aXR5KSA9PiBIVE1MX0VOVElUSUVTW2VudGl0eV0gfHwgXCInXCIpO1xufVxuXG5mdW5jdGlvbiBzZXRDU1NWYXIoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGVsLnN0eWxlLnNldFByb3BlcnR5KGAtLSR7bmFtZX1gLCB2YWx1ZSArIFwiXCIpO1xufVxuZnVuY3Rpb24gc2V0RGF0YUF0dHIoZWwsIG5hbWUsIHZhbHVlID0gdHJ1ZSkge1xuICBlbC5zZXRBdHRyaWJ1dGUoYGRhdGEtJHtuYW1lfWAsIHZhbHVlID09PSB0cnVlID8gXCJcIiA6IHZhbHVlICsgXCJcIik7XG59XG5mdW5jdGlvbiBzZXRQYXJ0QXR0cihlbCwgbmFtZSkge1xuICBlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBhcnRcIiwgbmFtZSk7XG59XG5mdW5jdGlvbiBnZXRMaW5lSGVpZ2h0KGVsKSB7XG4gIHJldHVybiBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZWwpLmxpbmVIZWlnaHQpIHx8IDA7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZUVEN1ZVRlbXBsYXRlKGN1ZSkge1xuICBpZiAoSVNfU0VSVkVSKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBcIlttZWRpYS1jYXB0aW9uc10gY2FsbGVkIGBjcmVhdGVWVFRDdWVUZW1wbGF0ZWAgb24gdGhlIHNlcnZlciAtIHVzZSBgcmVuZGVyVlRUQ3VlU3RyaW5nYFwiXG4gICAgKTtcbiAgfVxuICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgdGVtcGxhdGUuaW5uZXJIVE1MID0gcmVuZGVyVlRUQ3VlU3RyaW5nKGN1ZSk7XG4gIHJldHVybiB7IGN1ZSwgY29udGVudDogdGVtcGxhdGUuY29udGVudCB9O1xufVxuZnVuY3Rpb24gcmVuZGVyVlRUQ3VlU3RyaW5nKGN1ZSwgY3VycmVudFRpbWUgPSAwKSB7XG4gIHJldHVybiByZW5kZXJWVFRUb2tlbnNTdHJpbmcodG9rZW5pemVWVFRDdWUoY3VlKSwgY3VycmVudFRpbWUpO1xufVxuZnVuY3Rpb24gcmVuZGVyVlRUVG9rZW5zU3RyaW5nKHRva2VucywgY3VycmVudFRpbWUgPSAwKSB7XG4gIGxldCBhdHRycywgcmVzdWx0ID0gXCJcIjtcbiAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIHJlc3VsdCArPSB0b2tlbi5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpc1RpbWVzdGFtcCA9IHRva2VuLnR5cGUgPT09IFwidGltZXN0YW1wXCI7XG4gICAgICBhdHRycyA9IHt9O1xuICAgICAgYXR0cnMuY2xhc3MgPSB0b2tlbi5jbGFzcztcbiAgICAgIGF0dHJzLnRpdGxlID0gdG9rZW4udHlwZSA9PT0gXCJ2XCIgJiYgdG9rZW4udm9pY2U7XG4gICAgICBhdHRycy5sYW5nID0gdG9rZW4udHlwZSA9PT0gXCJsYW5nXCIgJiYgdG9rZW4ubGFuZztcbiAgICAgIGF0dHJzW1wiZGF0YS1wYXJ0XCJdID0gdG9rZW4udHlwZSA9PT0gXCJ2XCIgJiYgXCJ2b2ljZVwiO1xuICAgICAgaWYgKGlzVGltZXN0YW1wKSB7XG4gICAgICAgIGF0dHJzW1wiZGF0YS1wYXJ0XCJdID0gXCJ0aW1lZFwiO1xuICAgICAgICBhdHRyc1tcImRhdGEtdGltZVwiXSA9IHRva2VuLnRpbWU7XG4gICAgICAgIGF0dHJzW1wiZGF0YS1mdXR1cmVcIl0gPSB0b2tlbi50aW1lID4gY3VycmVudFRpbWU7XG4gICAgICAgIGF0dHJzW1wiZGF0YS1wYXN0XCJdID0gdG9rZW4udGltZSA8IGN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgYXR0cnMuc3R5bGUgPSBgJHt0b2tlbi5jb2xvciA/IGBjb2xvcjogJHt0b2tlbi5jb2xvcn07YCA6IFwiXCJ9JHt0b2tlbi5iZ0NvbG9yID8gYGJhY2tncm91bmQtY29sb3I6ICR7dG9rZW4uYmdDb2xvcn07YCA6IFwiXCJ9YDtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QuZW50cmllcyhhdHRycykuZmlsdGVyKCh2KSA9PiB2WzFdKS5tYXAoKHYpID0+IGAke3ZbMF19PVwiJHt2WzFdID09PSB0cnVlID8gXCJcIiA6IHZbMV19XCJgKS5qb2luKFwiIFwiKTtcbiAgICAgIHJlc3VsdCArPSBgPCR7dG9rZW4udGFnTmFtZX0ke2F0dHJpYnV0ZXMgPyBcIiBcIiArIGF0dHJpYnV0ZXMgOiBcIlwifT4ke3JlbmRlclZUVFRva2Vuc1N0cmluZyhcbiAgICAgICAgdG9rZW4uY2hpbGRyZW5cbiAgICAgICl9PC8ke3Rva2VuLnRhZ05hbWV9PmA7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1cGRhdGVUaW1lZFZUVEN1ZU5vZGVzKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIGlmIChJU19TRVJWRVIpXG4gICAgcmV0dXJuO1xuICBmb3IgKGNvbnN0IGVsIG9mIHJvb3QucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtcGFydD1cInRpbWVkXCJdJykpIHtcbiAgICBjb25zdCB0aW1lID0gTnVtYmVyKGVsLmdldEF0dHJpYnV0ZShcImRhdGEtdGltZVwiKSk7XG4gICAgaWYgKE51bWJlci5pc05hTih0aW1lKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICh0aW1lID4gY3VycmVudFRpbWUpXG4gICAgICBzZXREYXRhQXR0cihlbCwgXCJmdXR1cmVcIik7XG4gICAgZWxzZVxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1mdXR1cmVcIik7XG4gICAgaWYgKHRpbWUgPCBjdXJyZW50VGltZSlcbiAgICAgIHNldERhdGFBdHRyKGVsLCBcInBhc3RcIik7XG4gICAgZWxzZVxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1wYXN0XCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCBkZWxheSkge1xuICBsZXQgdGltZW91dCA9IG51bGwsIGFyZ3M7XG4gIGZ1bmN0aW9uIHJ1bigpIHtcbiAgICBjbGVhcigpO1xuICAgIGZuKC4uLmFyZ3MpO1xuICAgIGFyZ3MgPSB2b2lkIDA7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGRlYm91bmNlMigpIHtcbiAgICBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGNsZWFyKCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQocnVuLCBkZWxheSk7XG4gIH1cbiAgcmV0dXJuIGRlYm91bmNlMjtcbn1cblxuY29uc3QgU1RBUlRJTkdfQk9YID0gU3ltYm9sKFwiU1RBUlRJTkdfQk9YXCIgKTtcbmZ1bmN0aW9uIGNyZWF0ZUJveChib3gpIHtcbiAgaWYgKGJveCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogYm94Lm9mZnNldFRvcCxcbiAgICAgIHdpZHRoOiBib3guY2xpZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IGJveC5jbGllbnRIZWlnaHQsXG4gICAgICBsZWZ0OiBib3gub2Zmc2V0TGVmdCxcbiAgICAgIHJpZ2h0OiBib3gub2Zmc2V0TGVmdCArIGJveC5jbGllbnRXaWR0aCxcbiAgICAgIGJvdHRvbTogYm94Lm9mZnNldFRvcCArIGJveC5jbGllbnRIZWlnaHRcbiAgICB9O1xuICB9XG4gIHJldHVybiB7IC4uLmJveCB9O1xufVxuZnVuY3Rpb24gbW92ZUJveChib3gsIGF4aXMsIGRlbHRhKSB7XG4gIHN3aXRjaCAoYXhpcykge1xuICAgIGNhc2UgXCIreFwiOlxuICAgICAgYm94LmxlZnQgKz0gZGVsdGE7XG4gICAgICBib3gucmlnaHQgKz0gZGVsdGE7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiLXhcIjpcbiAgICAgIGJveC5sZWZ0IC09IGRlbHRhO1xuICAgICAgYm94LnJpZ2h0IC09IGRlbHRhO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIit5XCI6XG4gICAgICBib3gudG9wICs9IGRlbHRhO1xuICAgICAgYm94LmJvdHRvbSArPSBkZWx0YTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIteVwiOlxuICAgICAgYm94LnRvcCAtPSBkZWx0YTtcbiAgICAgIGJveC5ib3R0b20gLT0gZGVsdGE7XG4gICAgICBicmVhaztcbiAgfVxufVxuZnVuY3Rpb24gaXNCb3hDb2xsaXNpb24oYSwgYikge1xuICByZXR1cm4gYS5sZWZ0IDw9IGIucmlnaHQgJiYgYS5yaWdodCA+PSBiLmxlZnQgJiYgYS50b3AgPD0gYi5ib3R0b20gJiYgYS5ib3R0b20gPj0gYi50b3A7XG59XG5mdW5jdGlvbiBpc0FueUJveENvbGxpc2lvbihib3gsIGJveGVzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYm94ZXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKGlzQm94Q29sbGlzaW9uKGJveCwgYm94ZXNbaV0pKVxuICAgICAgcmV0dXJuIGJveGVzW2ldO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzV2l0aGluQm94KGNvbnRhaW5lciwgYm94KSB7XG4gIHJldHVybiBib3gudG9wID49IDAgJiYgYm94LmJvdHRvbSA8PSBjb250YWluZXIuaGVpZ2h0ICYmIGJveC5sZWZ0ID49IDAgJiYgYm94LnJpZ2h0IDw9IGNvbnRhaW5lci53aWR0aDtcbn1cbmZ1bmN0aW9uIGlzQm94T3V0T2ZCb3VuZHMoY29udGFpbmVyLCBib3gsIGF4aXMpIHtcbiAgc3dpdGNoIChheGlzKSB7XG4gICAgY2FzZSBcIit4XCI6XG4gICAgICByZXR1cm4gYm94LmxlZnQgPCAwO1xuICAgIGNhc2UgXCIteFwiOlxuICAgICAgcmV0dXJuIGJveC5yaWdodCA+IGNvbnRhaW5lci53aWR0aDtcbiAgICBjYXNlIFwiK3lcIjpcbiAgICAgIHJldHVybiBib3gudG9wIDwgMDtcbiAgICBjYXNlIFwiLXlcIjpcbiAgICAgIHJldHVybiBib3guYm90dG9tID4gY29udGFpbmVyLmhlaWdodDtcbiAgfVxufVxuZnVuY3Rpb24gY2FsY0JveEludGVyc2VjdFBlcmNlbnRhZ2UoY29udGFpbmVyLCBib3gpIHtcbiAgY29uc3QgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNvbnRhaW5lci53aWR0aCwgYm94LnJpZ2h0KSAtIE1hdGgubWF4KDAsIGJveC5sZWZ0KSksIHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjb250YWluZXIuaGVpZ2h0LCBib3guYm90dG9tKSAtIE1hdGgubWF4KDAsIGJveC50b3ApKSwgaW50ZXJzZWN0QXJlYSA9IHggKiB5O1xuICByZXR1cm4gaW50ZXJzZWN0QXJlYSAvIChjb250YWluZXIuaGVpZ2h0ICogY29udGFpbmVyLndpZHRoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNTU0JveChjb250YWluZXIsIGJveCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogYm94LnRvcCAvIGNvbnRhaW5lci5oZWlnaHQsXG4gICAgbGVmdDogYm94LmxlZnQgLyBjb250YWluZXIud2lkdGgsXG4gICAgcmlnaHQ6IChjb250YWluZXIud2lkdGggLSBib3gucmlnaHQpIC8gY29udGFpbmVyLndpZHRoLFxuICAgIGJvdHRvbTogKGNvbnRhaW5lci5oZWlnaHQgLSBib3guYm90dG9tKSAvIGNvbnRhaW5lci5oZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVSZWxhdGl2ZUJveChjb250YWluZXIsIGJveCkge1xuICBib3gudG9wID0gYm94LnRvcCAqIGNvbnRhaW5lci5oZWlnaHQ7XG4gIGJveC5sZWZ0ID0gYm94LmxlZnQgKiBjb250YWluZXIud2lkdGg7XG4gIGJveC5yaWdodCA9IGNvbnRhaW5lci53aWR0aCAtIGJveC5yaWdodCAqIGNvbnRhaW5lci53aWR0aDtcbiAgYm94LmJvdHRvbSA9IGNvbnRhaW5lci5oZWlnaHQgLSBib3guYm90dG9tICogY29udGFpbmVyLmhlaWdodDtcbiAgcmV0dXJuIGJveDtcbn1cbmNvbnN0IEJPWF9TSURFUyA9IFtcInRvcFwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiXTtcbmZ1bmN0aW9uIHNldEJveENTU1ZhcnMoZWwsIGNvbnRhaW5lciwgYm94LCBwcmVmaXgpIHtcbiAgY29uc3QgY3NzQm94ID0gY3JlYXRlQ1NTQm94KGNvbnRhaW5lciwgYm94KTtcbiAgZm9yIChjb25zdCBzaWRlIG9mIEJPWF9TSURFUykge1xuICAgIHNldENTU1ZhcihlbCwgYCR7cHJlZml4fS0ke3NpZGV9YCwgY3NzQm94W3NpZGVdICogMTAwICsgXCIlXCIpO1xuICB9XG59XG5mdW5jdGlvbiBhdm9pZEJveENvbGxpc2lvbnMoY29udGFpbmVyLCBib3gsIGJveGVzLCBheGlzKSB7XG4gIGxldCBwZXJjZW50YWdlID0gMSwgcG9zaXRpb25lZEJveCwgc3RhcnRCb3ggPSB7IC4uLmJveCB9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGF4aXMubGVuZ3RoOyBpKyspIHtcbiAgICB3aGlsZSAoaXNCb3hPdXRPZkJvdW5kcyhjb250YWluZXIsIGJveCwgYXhpc1tpXSkgfHwgaXNXaXRoaW5Cb3goY29udGFpbmVyLCBib3gpICYmIGlzQW55Qm94Q29sbGlzaW9uKGJveCwgYm94ZXMpKSB7XG4gICAgICBtb3ZlQm94KGJveCwgYXhpc1tpXSwgMSk7XG4gICAgfVxuICAgIGlmIChpc1dpdGhpbkJveChjb250YWluZXIsIGJveCkpXG4gICAgICByZXR1cm4gYm94O1xuICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IGNhbGNCb3hJbnRlcnNlY3RQZXJjZW50YWdlKGNvbnRhaW5lciwgYm94KTtcbiAgICBpZiAocGVyY2VudGFnZSA+IGludGVyc2VjdGlvbikge1xuICAgICAgcG9zaXRpb25lZEJveCA9IHsgLi4uYm94IH07XG4gICAgICBwZXJjZW50YWdlID0gaW50ZXJzZWN0aW9uO1xuICAgIH1cbiAgICBib3ggPSB7IC4uLnN0YXJ0Qm94IH07XG4gIH1cbiAgcmV0dXJuIHBvc2l0aW9uZWRCb3ggfHwgc3RhcnRCb3g7XG59XG5cbmNvbnN0IFBPU0lUSU9OX09WRVJSSURFID0gU3ltYm9sKFwiUE9TSVRJT05fT1ZFUlJJREVcIiApO1xuZnVuY3Rpb24gcG9zaXRpb25DdWUoY29udGFpbmVyLCBjdWUsIGRpc3BsYXlFbCwgYm94ZXMpIHtcbiAgbGV0IGN1ZUVsID0gZGlzcGxheUVsLmZpcnN0RWxlbWVudENoaWxkLCBsaW5lID0gY29tcHV0ZUN1ZUxpbmUoY3VlKSwgZGlzcGxheUJveCwgYXhpcyA9IFtdO1xuICBpZiAoIWRpc3BsYXlFbFtTVEFSVElOR19CT1hdKSB7XG4gICAgZGlzcGxheUVsW1NUQVJUSU5HX0JPWF0gPSBjcmVhdGVTdGFydGluZ0JveChjb250YWluZXIsIGRpc3BsYXlFbCk7XG4gIH1cbiAgZGlzcGxheUJveCA9IHJlc29sdmVSZWxhdGl2ZUJveChjb250YWluZXIsIHsgLi4uZGlzcGxheUVsW1NUQVJUSU5HX0JPWF0gfSk7XG4gIGlmIChkaXNwbGF5RWxbUE9TSVRJT05fT1ZFUlJJREVdKSB7XG4gICAgYXhpcyA9IFtkaXNwbGF5RWxbUE9TSVRJT05fT1ZFUlJJREVdID09PSBcInRvcFwiID8gXCIreVwiIDogXCIteVwiLCBcIit4XCIsIFwiLXhcIl07XG4gIH0gZWxzZSBpZiAoY3VlLnNuYXBUb0xpbmVzKSB7XG4gICAgbGV0IHNpemU7XG4gICAgc3dpdGNoIChjdWUudmVydGljYWwpIHtcbiAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgYXhpcyA9IFtcIit5XCIsIFwiLXlcIl07XG4gICAgICAgIHNpemUgPSBcImhlaWdodFwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJybFwiOlxuICAgICAgICBheGlzID0gW1wiK3hcIiwgXCIteFwiXTtcbiAgICAgICAgc2l6ZSA9IFwid2lkdGhcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibHJcIjpcbiAgICAgICAgYXhpcyA9IFtcIi14XCIsIFwiK3hcIl07XG4gICAgICAgIHNpemUgPSBcIndpZHRoXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgc3RlcCA9IGdldExpbmVIZWlnaHQoY3VlRWwpLCBwb3NpdGlvbiA9IHN0ZXAgKiBNYXRoLnJvdW5kKGxpbmUpLCBtYXhQb3NpdGlvbiA9IGNvbnRhaW5lcltzaXplXSArIHN0ZXAsIGluaXRpYWxBeGlzID0gYXhpc1swXTtcbiAgICBpZiAoTWF0aC5hYnMocG9zaXRpb24pID4gbWF4UG9zaXRpb24pIHtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPCAwID8gLTEgOiAxO1xuICAgICAgcG9zaXRpb24gKj0gTWF0aC5jZWlsKG1heFBvc2l0aW9uIC8gc3RlcCkgKiBzdGVwO1xuICAgIH1cbiAgICBpZiAobGluZSA8IDApIHtcbiAgICAgIHBvc2l0aW9uICs9IGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIiA/IGNvbnRhaW5lci5oZWlnaHQgOiBjb250YWluZXIud2lkdGg7XG4gICAgICBheGlzID0gYXhpcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIG1vdmVCb3goZGlzcGxheUJveCwgaW5pdGlhbEF4aXMsIHBvc2l0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBjdWUudmVydGljYWwgPT09IFwiXCIsIHBvc0F4aXMgPSBpc0hvcml6b250YWwgPyBcIit5XCIgOiBcIit4XCIsIHNpemUgPSBpc0hvcml6b250YWwgPyBkaXNwbGF5Qm94LmhlaWdodCA6IGRpc3BsYXlCb3gud2lkdGg7XG4gICAgbW92ZUJveChcbiAgICAgIGRpc3BsYXlCb3gsXG4gICAgICBwb3NBeGlzLFxuICAgICAgKGlzSG9yaXpvbnRhbCA/IGNvbnRhaW5lci5oZWlnaHQgOiBjb250YWluZXIud2lkdGgpICogbGluZSAvIDEwMFxuICAgICk7XG4gICAgbW92ZUJveChcbiAgICAgIGRpc3BsYXlCb3gsXG4gICAgICBwb3NBeGlzLFxuICAgICAgY3VlLmxpbmVBbGlnbiA9PT0gXCJjZW50ZXJcIiA/IHNpemUgLyAyIDogY3VlLmxpbmVBbGlnbiA9PT0gXCJlbmRcIiA/IHNpemUgOiAwXG4gICAgKTtcbiAgICBheGlzID0gaXNIb3Jpem9udGFsID8gW1wiLXlcIiwgXCIreVwiLCBcIi14XCIsIFwiK3hcIl0gOiBbXCIteFwiLCBcIit4XCIsIFwiLXlcIiwgXCIreVwiXTtcbiAgfVxuICBkaXNwbGF5Qm94ID0gYXZvaWRCb3hDb2xsaXNpb25zKGNvbnRhaW5lciwgZGlzcGxheUJveCwgYm94ZXMsIGF4aXMpO1xuICBzZXRCb3hDU1NWYXJzKGRpc3BsYXlFbCwgY29udGFpbmVyLCBkaXNwbGF5Qm94LCBcImN1ZVwiKTtcbiAgcmV0dXJuIGRpc3BsYXlCb3g7XG59XG5mdW5jdGlvbiBjcmVhdGVTdGFydGluZ0JveChjb250YWluZXIsIGN1ZUVsKSB7XG4gIGNvbnN0IGJveCA9IGNyZWF0ZUJveChjdWVFbCksIHBvcyA9IGdldFN0eWxlZFBvc2l0aW9ucyhjdWVFbCk7XG4gIGN1ZUVsW1BPU0lUSU9OX09WRVJSSURFXSA9IGZhbHNlO1xuICBpZiAocG9zLnRvcCkge1xuICAgIGJveC50b3AgPSBwb3MudG9wO1xuICAgIGJveC5ib3R0b20gPSBwb3MudG9wICsgYm94LmhlaWdodDtcbiAgICBjdWVFbFtQT1NJVElPTl9PVkVSUklERV0gPSBcInRvcFwiO1xuICB9XG4gIGlmIChwb3MuYm90dG9tKSB7XG4gICAgY29uc3QgYm90dG9tID0gY29udGFpbmVyLmhlaWdodCAtIHBvcy5ib3R0b207XG4gICAgYm94LnRvcCA9IGJvdHRvbSAtIGJveC5oZWlnaHQ7XG4gICAgYm94LmJvdHRvbSA9IGJvdHRvbTtcbiAgICBjdWVFbFtQT1NJVElPTl9PVkVSUklERV0gPSBcImJvdHRvbVwiO1xuICB9XG4gIGlmIChwb3MubGVmdClcbiAgICBib3gubGVmdCA9IHBvcy5sZWZ0O1xuICBpZiAocG9zLnJpZ2h0KVxuICAgIGJveC5yaWdodCA9IGNvbnRhaW5lci53aWR0aCAtIHBvcy5yaWdodDtcbiAgcmV0dXJuIGNyZWF0ZUNTU0JveChjb250YWluZXIsIGJveCk7XG59XG5mdW5jdGlvbiBnZXRTdHlsZWRQb3NpdGlvbnMoZWwpIHtcbiAgY29uc3QgcG9zaXRpb25zID0ge307XG4gIGZvciAoY29uc3Qgc2lkZSBvZiBCT1hfU0lERVMpIHtcbiAgICBwb3NpdGlvbnNbc2lkZV0gPSBwYXJzZUZsb2F0KGVsLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoYC0tY3VlLSR7c2lkZX1gKSk7XG4gIH1cbiAgcmV0dXJuIHBvc2l0aW9ucztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDdWVMaW5lKGN1ZSkge1xuICBpZiAoY3VlLmxpbmUgPT09IFwiYXV0b1wiKSB7XG4gICAgaWYgKCFjdWUuc25hcFRvTGluZXMpIHtcbiAgICAgIHJldHVybiAxMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1ZS5saW5lO1xufVxuZnVuY3Rpb24gY29tcHV0ZUN1ZVBvc2l0aW9uKGN1ZSkge1xuICBpZiAoY3VlLnBvc2l0aW9uID09PSBcImF1dG9cIikge1xuICAgIHN3aXRjaCAoY3VlLmFsaWduKSB7XG4gICAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgIHJldHVybiAxMDA7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gNTA7XG4gICAgfVxuICB9XG4gIHJldHVybiBjdWUucG9zaXRpb247XG59XG5mdW5jdGlvbiBjb21wdXRlQ3VlUG9zaXRpb25BbGlnbm1lbnQoY3VlLCBkaXIpIHtcbiAgaWYgKGN1ZS5wb3NpdGlvbkFsaWduID09PSBcImF1dG9cIikge1xuICAgIHN3aXRjaCAoY3VlLmFsaWduKSB7XG4gICAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgICAgcmV0dXJuIGRpciA9PT0gXCJsdHJcIiA/IFwibGluZS1sZWZ0XCIgOiBcImxpbmUtcmlnaHRcIjtcbiAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgcmV0dXJuIGRpciA9PT0gXCJsdHJcIiA/IFwibGluZS1yaWdodFwiIDogXCJsaW5lLWxlZnRcIjtcbiAgICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgICAgcmV0dXJuIFwiY2VudGVyXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYGxpbmUtJHtjdWUuYWxpZ259YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1ZS5wb3NpdGlvbkFsaWduO1xufVxuXG5jb25zdCBSRUdJT05fQVhJUyA9IFtcIi15XCIsIFwiK3lcIiwgXCIteFwiLCBcIit4XCJdO1xuZnVuY3Rpb24gcG9zaXRpb25SZWdpb24oY29udGFpbmVyLCByZWdpb24sIHJlZ2lvbkVsLCBib3hlcykge1xuICBsZXQgY3VlcyA9IEFycmF5LmZyb20ocmVnaW9uRWwucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtcGFydD1cImN1ZS1kaXNwbGF5XCJdJykpLCBoZWlnaHQgPSAwLCBsaW1pdCA9IE1hdGgubWF4KDAsIGN1ZXMubGVuZ3RoIC0gcmVnaW9uLmxpbmVzKTtcbiAgZm9yIChsZXQgaSA9IGN1ZXMubGVuZ3RoIC0gMTsgaSA+PSBsaW1pdDsgaS0tKSB7XG4gICAgaGVpZ2h0ICs9IGN1ZXNbaV0ub2Zmc2V0SGVpZ2h0O1xuICB9XG4gIHNldENTU1ZhcihyZWdpb25FbCwgXCJyZWdpb24taGVpZ2h0XCIsIGhlaWdodCArIFwicHhcIik7XG4gIGlmICghcmVnaW9uRWxbU1RBUlRJTkdfQk9YXSkge1xuICAgIHJlZ2lvbkVsW1NUQVJUSU5HX0JPWF0gPSBjcmVhdGVDU1NCb3goY29udGFpbmVyLCBjcmVhdGVCb3gocmVnaW9uRWwpKTtcbiAgfVxuICBsZXQgYm94ID0geyAuLi5yZWdpb25FbFtTVEFSVElOR19CT1hdIH07XG4gIGJveCA9IHJlc29sdmVSZWxhdGl2ZUJveChjb250YWluZXIsIGJveCk7XG4gIGJveC53aWR0aCA9IHJlZ2lvbkVsLmNsaWVudFdpZHRoO1xuICBib3guaGVpZ2h0ID0gaGVpZ2h0O1xuICBib3gucmlnaHQgPSBib3gubGVmdCArIGJveC53aWR0aDtcbiAgYm94LmJvdHRvbSA9IGJveC50b3AgKyBoZWlnaHQ7XG4gIGJveCA9IGF2b2lkQm94Q29sbGlzaW9ucyhjb250YWluZXIsIGJveCwgYm94ZXMsIFJFR0lPTl9BWElTKTtcbiAgc2V0Qm94Q1NTVmFycyhyZWdpb25FbCwgY29udGFpbmVyLCBib3gsIFwicmVnaW9uXCIpO1xuICByZXR1cm4gYm94O1xufVxuXG5jbGFzcyBDYXB0aW9uc1JlbmRlcmVyIHtcbiAgb3ZlcmxheTtcbiAgX292ZXJsYXlCb3g7XG4gIF9jdXJyZW50VGltZSA9IDA7XG4gIF9kaXIgPSBcImx0clwiO1xuICBfYWN0aXZlQ3VlcyA9IFtdO1xuICBfaXNSZXNpemluZyA9IGZhbHNlO1xuICBfcmVzaXplT2JzZXJ2ZXI7XG4gIF9yZWdpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX2N1ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvKiBUZXh0IGRpcmVjdGlvbi4gKi9cbiAgZ2V0IGRpcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlyO1xuICB9XG4gIHNldCBkaXIoZGlyKSB7XG4gICAgdGhpcy5fZGlyID0gZGlyO1xuICAgIHNldERhdGFBdHRyKHRoaXMub3ZlcmxheSwgXCJkaXJcIiwgZGlyKTtcbiAgfVxuICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUaW1lO1xuICB9XG4gIHNldCBjdXJyZW50VGltZSh0aW1lKSB7XG4gICAgdGhpcy5fY3VycmVudFRpbWUgPSB0aW1lO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgY29uc3RydWN0b3Iob3ZlcmxheSwgaW5pdCkge1xuICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgdGhpcy5kaXIgPSBpbml0Py5kaXIgPz8gXCJsdHJcIjtcbiAgICBvdmVybGF5LnNldEF0dHJpYnV0ZShcInRyYW5zbGF0ZVwiLCBcInllc1wiKTtcbiAgICBvdmVybGF5LnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcIm9mZlwiKTtcbiAgICBvdmVybGF5LnNldEF0dHJpYnV0ZShcImFyaWEtYXRvbWljXCIsIFwidHJ1ZVwiKTtcbiAgICBzZXRQYXJ0QXR0cihvdmVybGF5LCBcImNhcHRpb25zXCIpO1xuICAgIHRoaXMuX3VwZGF0ZU92ZXJsYXkoKTtcbiAgICB0aGlzLl9yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcih0aGlzLl9yZXNpemluZy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9yZXNpemVPYnNlcnZlci5vYnNlcnZlKG92ZXJsYXkpO1xuICB9XG4gIGNoYW5nZVRyYWNrKHsgcmVnaW9ucywgY3VlcyB9KSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuX2J1aWxkUmVnaW9ucyhyZWdpb25zKTtcbiAgICBmb3IgKGNvbnN0IGN1ZSBvZiBjdWVzKVxuICAgICAgdGhpcy5fY3Vlcy5zZXQoY3VlLCBudWxsKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIGFkZEN1ZShjdWUpIHtcbiAgICB0aGlzLl9jdWVzLnNldChjdWUsIG51bGwpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgcmVtb3ZlQ3VlKGN1ZSkge1xuICAgIHRoaXMuX2N1ZXMuZGVsZXRlKGN1ZSk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICB1cGRhdGUoZm9yY2VVcGRhdGUgPSBmYWxzZSkge1xuICAgIHRoaXMuX3JlbmRlcihmb3JjZVVwZGF0ZSk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fY3Vlcy5jbGVhcigpO1xuICAgIHRoaXMuX3JlZ2lvbnMuY2xlYXIoKTtcbiAgICB0aGlzLl9hY3RpdmVDdWVzID0gW107XG4gICAgdGhpcy5vdmVybGF5LnRleHRDb250ZW50ID0gXCJcIjtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLl9yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgX3Jlc2l6aW5nKCkge1xuICAgIHRoaXMuX2lzUmVzaXppbmcgPSB0cnVlO1xuICAgIHRoaXMuX3Jlc2l6ZSgpO1xuICB9XG4gIF9yZXNpemUgPSBkZWJvdW5jZSgoKSA9PiB7XG4gICAgdGhpcy5faXNSZXNpemluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3VwZGF0ZU92ZXJsYXkoKTtcbiAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMuX3JlZ2lvbnMudmFsdWVzKCkpIHtcbiAgICAgIGVsW1NUQVJUSU5HX0JPWF0gPSBudWxsO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMuX2N1ZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbClcbiAgICAgICAgZWxbU1RBUlRJTkdfQk9YXSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3JlbmRlcih0cnVlKTtcbiAgfSwgNTApO1xuICBfdXBkYXRlT3ZlcmxheSgpIHtcbiAgICB0aGlzLl9vdmVybGF5Qm94ID0gY3JlYXRlQm94KHRoaXMub3ZlcmxheSk7XG4gICAgc2V0Q1NTVmFyKHRoaXMub3ZlcmxheSwgXCJvdmVybGF5LXdpZHRoXCIsIHRoaXMuX292ZXJsYXlCb3gud2lkdGggKyBcInB4XCIpO1xuICAgIHNldENTU1Zhcih0aGlzLm92ZXJsYXksIFwib3ZlcmxheS1oZWlnaHRcIiwgdGhpcy5fb3ZlcmxheUJveC5oZWlnaHQgKyBcInB4XCIpO1xuICB9XG4gIF9yZW5kZXIoZm9yY2VVcGRhdGUgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy5fY3Vlcy5zaXplIHx8IHRoaXMuX2lzUmVzaXppbmcpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGN1ZSwgYWN0aXZlQ3VlcyA9IFsuLi50aGlzLl9jdWVzLmtleXMoKV0uZmlsdGVyKChjdWUyKSA9PiB0aGlzLl9jdXJyZW50VGltZSA+PSBjdWUyLnN0YXJ0VGltZSAmJiB0aGlzLl9jdXJyZW50VGltZSA8PSBjdWUyLmVuZFRpbWUpLnNvcnQoXG4gICAgICAoY3VlQSwgY3VlQikgPT4gY3VlQS5zdGFydFRpbWUgIT09IGN1ZUIuc3RhcnRUaW1lID8gY3VlQS5zdGFydFRpbWUgLSBjdWVCLnN0YXJ0VGltZSA6IGN1ZUEuZW5kVGltZSAtIGN1ZUIuZW5kVGltZVxuICAgICksIGFjdGl2ZVJlZ2lvbnMgPSBhY3RpdmVDdWVzLm1hcCgoY3VlMikgPT4gY3VlMi5yZWdpb24pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYWN0aXZlQ3Vlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY3VlID0gdGhpcy5fYWN0aXZlQ3Vlc1tpXTtcbiAgICAgIGlmIChhY3RpdmVDdWVzW2ldID09PSBjdWUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGN1ZS5yZWdpb24gJiYgIWFjdGl2ZVJlZ2lvbnMuaW5jbHVkZXMoY3VlLnJlZ2lvbikpIHtcbiAgICAgICAgY29uc3QgcmVnaW9uRWwgPSB0aGlzLl9yZWdpb25zLmdldChjdWUucmVnaW9uLmlkKTtcbiAgICAgICAgaWYgKHJlZ2lvbkVsKSB7XG4gICAgICAgICAgcmVnaW9uRWwucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1hY3RpdmVcIik7XG4gICAgICAgICAgZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjdWVFbCA9IHRoaXMuX2N1ZXMuZ2V0KGN1ZSk7XG4gICAgICBpZiAoY3VlRWwpIHtcbiAgICAgICAgY3VlRWwucmVtb3ZlKCk7XG4gICAgICAgIGZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3RpdmVDdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdWUgPSBhY3RpdmVDdWVzW2ldO1xuICAgICAgbGV0IGN1ZUVsID0gdGhpcy5fY3Vlcy5nZXQoY3VlKTtcbiAgICAgIGlmICghY3VlRWwpXG4gICAgICAgIHRoaXMuX2N1ZXMuc2V0KGN1ZSwgY3VlRWwgPSB0aGlzLl9jcmVhdGVDdWVFbGVtZW50KGN1ZSkpO1xuICAgICAgY29uc3QgcmVnaW9uRWwgPSB0aGlzLl9oYXNSZWdpb24oY3VlKSAmJiB0aGlzLl9yZWdpb25zLmdldChjdWUucmVnaW9uLmlkKTtcbiAgICAgIGlmIChyZWdpb25FbCAmJiAhcmVnaW9uRWwuaGFzQXR0cmlidXRlKFwiZGF0YS1hY3RpdmVcIikpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHNldERhdGFBdHRyKHJlZ2lvbkVsLCBcImFjdGl2ZVwiKSk7XG4gICAgICAgIGZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghY3VlRWwuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgKHJlZ2lvbkVsIHx8IHRoaXMub3ZlcmxheSkuYXBwZW5kKGN1ZUVsKTtcbiAgICAgICAgZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm9yY2VVcGRhdGUpIHtcbiAgICAgIGNvbnN0IGJveGVzID0gW10sIHNlZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUN1ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY3VlID0gYWN0aXZlQ3Vlc1tpXTtcbiAgICAgICAgaWYgKHNlZW4uaGFzKGN1ZS5yZWdpb24gfHwgY3VlKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgaXNSZWdpb24gPSB0aGlzLl9oYXNSZWdpb24oY3VlKSwgZWwgPSBpc1JlZ2lvbiA/IHRoaXMuX3JlZ2lvbnMuZ2V0KGN1ZS5yZWdpb24uaWQpIDogdGhpcy5fY3Vlcy5nZXQoY3VlKTtcbiAgICAgICAgaWYgKGlzUmVnaW9uKSB7XG4gICAgICAgICAgYm94ZXMucHVzaChwb3NpdGlvblJlZ2lvbih0aGlzLl9vdmVybGF5Qm94LCBjdWUucmVnaW9uLCBlbCwgYm94ZXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBib3hlcy5wdXNoKHBvc2l0aW9uQ3VlKHRoaXMuX292ZXJsYXlCb3gsIGN1ZSwgZWwsIGJveGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5hZGQoaXNSZWdpb24gPyBjdWUucmVnaW9uIDogY3VlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlVGltZWRWVFRDdWVOb2Rlcyh0aGlzLm92ZXJsYXksIHRoaXMuX2N1cnJlbnRUaW1lKTtcbiAgICB0aGlzLl9hY3RpdmVDdWVzID0gYWN0aXZlQ3VlcztcbiAgfVxuICBfYnVpbGRSZWdpb25zKHJlZ2lvbnMpIHtcbiAgICBpZiAoIXJlZ2lvbnMpXG4gICAgICByZXR1cm47XG4gICAgZm9yIChjb25zdCByZWdpb24gb2YgcmVnaW9ucykge1xuICAgICAgY29uc3QgZWwgPSB0aGlzLl9jcmVhdGVSZWdpb25FbGVtZW50KHJlZ2lvbik7XG4gICAgICB0aGlzLl9yZWdpb25zLnNldChyZWdpb24uaWQsIGVsKTtcbiAgICAgIHRoaXMub3ZlcmxheS5hcHBlbmQoZWwpO1xuICAgIH1cbiAgfVxuICBfY3JlYXRlUmVnaW9uRWxlbWVudChyZWdpb24pIHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgc2V0UGFydEF0dHIoZWwsIFwicmVnaW9uXCIpO1xuICAgIHNldERhdGFBdHRyKGVsLCBcImlkXCIsIHJlZ2lvbi5pZCk7XG4gICAgc2V0RGF0YUF0dHIoZWwsIFwic2Nyb2xsXCIsIHJlZ2lvbi5zY3JvbGwpO1xuICAgIHNldENTU1ZhcihlbCwgXCJyZWdpb24td2lkdGhcIiwgcmVnaW9uLndpZHRoICsgXCIlXCIpO1xuICAgIHNldENTU1ZhcihlbCwgXCJyZWdpb24tYW5jaG9yLXhcIiwgcmVnaW9uLnJlZ2lvbkFuY2hvclgpO1xuICAgIHNldENTU1ZhcihlbCwgXCJyZWdpb24tYW5jaG9yLXlcIiwgcmVnaW9uLnJlZ2lvbkFuY2hvclkpO1xuICAgIHNldENTU1ZhcihlbCwgXCJyZWdpb24tdmlld3BvcnQtYW5jaG9yLXhcIiwgcmVnaW9uLnZpZXdwb3J0QW5jaG9yWCk7XG4gICAgc2V0Q1NTVmFyKGVsLCBcInJlZ2lvbi12aWV3cG9ydC1hbmNob3IteVwiLCByZWdpb24udmlld3BvcnRBbmNob3JZKTtcbiAgICBzZXRDU1NWYXIoZWwsIFwicmVnaW9uLWxpbmVzXCIsIHJlZ2lvbi5saW5lcyk7XG4gICAgcmV0dXJuIGVsO1xuICB9XG4gIF9jcmVhdGVDdWVFbGVtZW50KGN1ZSkge1xuICAgIGNvbnN0IGRpc3BsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBwb3NpdGlvbiA9IGNvbXB1dGVDdWVQb3NpdGlvbihjdWUpLCBwb3NpdGlvbkFsaWdubWVudCA9IGNvbXB1dGVDdWVQb3NpdGlvbkFsaWdubWVudChjdWUsIHRoaXMuX2Rpcik7XG4gICAgc2V0UGFydEF0dHIoZGlzcGxheSwgXCJjdWUtZGlzcGxheVwiKTtcbiAgICBpZiAoY3VlLnZlcnRpY2FsICE9PSBcIlwiKVxuICAgICAgc2V0RGF0YUF0dHIoZGlzcGxheSwgXCJ2ZXJ0aWNhbFwiKTtcbiAgICBzZXRDU1NWYXIoZGlzcGxheSwgXCJjdWUtdGV4dC1hbGlnblwiLCBjdWUuYWxpZ24pO1xuICAgIGlmIChjdWUuc3R5bGUpIHtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3Qua2V5cyhjdWUuc3R5bGUpKSB7XG4gICAgICAgIGRpc3BsYXkuc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgY3VlLnN0eWxlW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLl9oYXNSZWdpb24oY3VlKSkge1xuICAgICAgc2V0Q1NTVmFyKFxuICAgICAgICBkaXNwbGF5LFxuICAgICAgICBcImN1ZS13cml0aW5nLW1vZGVcIixcbiAgICAgICAgY3VlLnZlcnRpY2FsID09PSBcIlwiID8gXCJob3Jpem9udGFsLXRiXCIgOiBjdWUudmVydGljYWwgPT09IFwibHJcIiA/IFwidmVydGljYWwtbHJcIiA6IFwidmVydGljYWwtcmxcIlxuICAgICAgKTtcbiAgICAgIGlmICghY3VlLnN0eWxlPy5bXCItLWN1ZS13aWR0aFwiXSkge1xuICAgICAgICBsZXQgbWF4U2l6ZSA9IHBvc2l0aW9uO1xuICAgICAgICBpZiAocG9zaXRpb25BbGlnbm1lbnQgPT09IFwibGluZS1sZWZ0XCIpIHtcbiAgICAgICAgICBtYXhTaXplID0gMTAwIC0gcG9zaXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb25BbGlnbm1lbnQgPT09IFwiY2VudGVyXCIgJiYgcG9zaXRpb24gPD0gNTApIHtcbiAgICAgICAgICBtYXhTaXplID0gcG9zaXRpb24gKiAyO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uQWxpZ25tZW50ID09PSBcImNlbnRlclwiICYmIHBvc2l0aW9uID4gNTApIHtcbiAgICAgICAgICBtYXhTaXplID0gKDEwMCAtIHBvc2l0aW9uKSAqIDI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZSA9IGN1ZS5zaXplIDwgbWF4U2l6ZSA/IGN1ZS5zaXplIDogbWF4U2l6ZTtcbiAgICAgICAgaWYgKGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIilcbiAgICAgICAgICBzZXRDU1NWYXIoZGlzcGxheSwgXCJjdWUtd2lkdGhcIiwgc2l6ZSArIFwiJVwiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNldENTU1ZhcihkaXNwbGF5LCBcImN1ZS1oZWlnaHRcIiwgc2l6ZSArIFwiJVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0Q1NTVmFyKFxuICAgICAgICBkaXNwbGF5LFxuICAgICAgICBcImN1ZS1vZmZzZXRcIixcbiAgICAgICAgYCR7cG9zaXRpb24gLSAocG9zaXRpb25BbGlnbm1lbnQgPT09IFwibGluZS1yaWdodFwiID8gMTAwIDogcG9zaXRpb25BbGlnbm1lbnQgPT09IFwiY2VudGVyXCIgPyA1MCA6IDApfSVgXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgc2V0UGFydEF0dHIoZWwsIFwiY3VlXCIpO1xuICAgIGlmIChjdWUuaWQpXG4gICAgICBzZXREYXRhQXR0cihlbCwgXCJpZFwiLCBjdWUuaWQpO1xuICAgIGVsLmlubmVySFRNTCA9IHJlbmRlclZUVEN1ZVN0cmluZyhjdWUpO1xuICAgIGRpc3BsYXkuYXBwZW5kKGVsKTtcbiAgICByZXR1cm4gZGlzcGxheTtcbiAgfVxuICBfaGFzUmVnaW9uKGN1ZSkge1xuICAgIHJldHVybiBjdWUucmVnaW9uICYmIGN1ZS5zaXplID09PSAxMDAgJiYgY3VlLnZlcnRpY2FsID09PSBcIlwiICYmIGN1ZS5saW5lID09PSBcImF1dG9cIjtcbiAgfVxufVxuXG5leHBvcnQgeyBDYXB0aW9uc1JlbmRlcmVyIGFzIEMsIFBhcnNlRXJyb3IgYXMgUCwgVGV4dEN1ZSBhcyBULCBWVFRQYXJzZXIgYXMgViwgVlRUQmxvY2sgYXMgYSwgVlRUQ3VlIGFzIGIsIFBhcnNlRXJyb3JDb2RlIGFzIGMsIHBhcnNlUmVzcG9uc2UgYXMgZCwgcGFyc2VCeXRlU3RyZWFtIGFzIGUsIHBhcnNlVGV4dCBhcyBmLCBwYXJzZVRleHRTdHJlYW0gYXMgZywgVlRUUmVnaW9uIGFzIGgsIGNyZWF0ZVZUVEN1ZVRlbXBsYXRlIGFzIGksIHJlbmRlclZUVFRva2Vuc1N0cmluZyBhcyBqLCBwYXJzZVZUVFRpbWVzdGFtcCBhcyBwLCByZW5kZXJWVFRDdWVTdHJpbmcgYXMgciwgdG9rZW5pemVWVFRDdWUgYXMgdCwgdXBkYXRlVGltZWRWVFRDdWVOb2RlcyBhcyB1IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-captions/dist/dev/index.js\n"));

/***/ })

}]);